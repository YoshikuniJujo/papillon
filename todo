**************************
* 次にやること           *
**************************

* ParseError を Papillon から export するようにする

* class Source とか ParseError とかを Papillon から export するようにする
	ParseError は Derivs を含むので無理だ。
	もし、するなら data ParseError pos drv = ... のようにする必要がある。
	class Source とかは可能だと思う。

* papillonStr' について
	関数名について考える
	また、ByteString や Text も扱うかどうかについても考えること
	これを Papillon から export する必要はないのかもしれない
	とすると、module 構造を変える必要があるな

* module 構造について
	Papillon -+-> some
                  |
	papillon -+
	とすることで、Papillon が papillonStr 等を export せずにすむ。
	ただし、papillonStr を export するのが役立つ可能性もあるので考えること

* リファクタリング

**************************
* parser の表記/機能関係 *
**************************

* \n や \t と stringE の関係について調べる
	ppr の問題なのかもしれない

* escapeC について
	\n, \t 以外の特殊文字についても考慮する
* 非終端記号に大文字で始まるものも許すようにしようかな
	これは prefix をつけることで可能と思われる
	camel, snake, raw の指定とからめて

**************************
*  warning 関係          *
**************************

* pePositionS に関する warning について
	これを消すのは難しいな
	これを消すためには ParseError と class Source 等を
	Papillon から export するようにする必要がある
	そのうえで、papillon では pePositionS という文字列を探して、
	存在すればこれを足すという必要があるな
	papillon のほうは解決

**************************
*  エラーメッセージ関係  *
**************************

* ParseError を表示する関数を TH で作成できないか考える
	問題はすべての型が Show であるわけではないというところだ。
	すべての型が Show である場合にのみ使える関数を TH で作ってもいいが ...
	いずれにしてもいろいろと考察すること

* peMessage で入手できる message について
	もっとちゃんとした英語にできるだろうか

**************************
*  リファクタリング関係  *
**************************

* 関数等の名前について
	つけるものを指定できるようにする
	指定がなければ何もつけないという感じ
	指定があればそれぞれの名前にそれがつく
	また parse にもそれをつけてしまおう
	それと行く行くは camel case 用のオプションをつけて、
	myParse とかそういうふうにできるようにしよう。
	自動で一番先頭を大文字にする。
	先頭の case だけ違うものについてはとりあえずは自己責任で。
	camel, snake, none から選べるようにするってのはありだな。

	derivsChars と derivsPosition は
	先々では camel, snake, none の値によって変えることにしようかな
	derivs_chars と derivs_position, derivschars と derivsposition のように

	Derivs も同様にする。ただし prefix の一文字目を大文字化する

	ParseError のフィールド名
	peCode, peMessage, peComment, peReadings, peDerivs, pePosition について
	snake や raw のときには、それぞれ
	pe_code, pe_message, pe_comment, pe_readings, pe_derivs, pe_position
	pecode, pemessage, pecomment, pereadings, pederivs, peposition の
	ようにする
	また prefix ももちろんつけることになるだろう

* papillon command は何も取らなければ filter とする。
	また、papillon [Input] や papillon [Input] -o [Output] の形も使う。
	そのうちに papillon -h や papillon --help も。
	より使いやすく GetOpt を使ってみるのもいいかもしれない。
* Text/Papillon/Parser.hs を git から外す
	これは papillon 自体がある程度安定してから、となるだろう。
* Parser.peg を token を使って書き直す
* ParseError の型をどうするか
	できたら型を公開しなくてもすむような形にしたいが
	つまり、型の構築子と reader だけを公開するという形にしたい

* data ParseError の型構築子を公開しないようにする
	data ParseError = ParseError ... を TH で書き、
	それは Papillon.hs にはりつけるのと、コードの変換時に追加するのとで使う。
	そして Papillon.hs からは ParseError は ParseError(..) とはしない
	作るときは makeParseError を使い、
	それぞれの field を入取するときも専用の関数を使う
	とりあえずはフィールド名を使っておけば良いと思う

* 上記は今の作りだと実行できない
	つまり、ParseError は Main で定義されているのでアクセス制限ができない
	mkParseError を作り、それを使うというのは未だにいい考えだが、
	上記ができないということで魅力は半減する

* ParseError は th が True のときには、Papillon からの export でもいいが...
	今のままでもいいし、どっちのほうがいいかな

* 今は Main 内でのみ使っているが、それ以外の module で使ったときに、
	未使用の warning が出ると思う
	それに対処すること

	pePositionS
	他の pe... もそうだが、module 内で使わない場合に warning が出てしまう
	あとで考えよう

******************************
*  機能面における細かい修正  *
******************************

* {-# LANGUAGE ... #-} がないときにはそれを追加する
* source の見直し
	今の文法だと、source: SomeSource\n のようになっているが
	今後より複雑な文法を許容した場合において ';' で区切ったほうが良いかもしれない
* 左再帰の解決はどうしようかな
	pappy はこれにひどく時間がかかっていた
* ; を省略可能にしようかな
	あるいは省略不可とするか
	省略不可のほうがインデントについての自由度が高くなり
	parser が簡単になる
* papillonStr' 等を String 以外も取れるようにする
	StringLike とかかな

**************************
*  ドキュメント関係      *
**************************

* cabal に examples directory を追加する
* cabal の description をもうすこしましにする
* homepage に example をのせる
	sakura VPS に papillon を install すれば、
	インタラクティブなページが作れるかな

**************************
*  パッケージ/開発関係   *
**************************

* hackage への登録をそろそろしようかな

* ~/local/portage/dev-haskell/papillon/ ディレクトリを整理
	古いバージョンは消してしまおう

* 機能追加やバグの修正など、些細な修正以外は branch を作ることにする
	作業用の branch を作り、問題が無ければ、master に marge して
	branch を消すという作業習慣をつけよう

**************************
*  後々やること          *
**************************

* 出来上がったコードを hlint で refactoring
* unicode への対応
* たとえば (Node l t):tree で warning が出ないようにする
	つまり、もしもそのパターンが反駁不可であるならば、
	_ -> ... を取らないようにする
	とりあえずは VarP と WildP のみを含むものを check しよう
	ひとつしか constructor を持たない物もそれらと同様に扱う必要がある
	これにはおそらく reify が必要になるので後々することにしよう
	これは th が True のときだけ reify を見るということで実現可能だろう
