* Maybe ではなく Either ParseError とする
	あるいはもっと一般的な Monad を取れるようにするのもいいかもしれない
	ただし、Error からの復帰が必要なので、MonadError m が必要だろう
	でも今の段階ではそうする理由もないので Either ParseError としよう
	type PackratM = StateT Derivs (Either ParseError) とする。
	その前に、instance MonadError Maybe としてみようか。
* String -> m (Char, String) をより一般的に s -> m (c, s) としよう。
	これには TypeFamilies を使った class によって可能だろう。
	ただし、これをやると、to file がうまくいかない。
	ここらへんも構文木の形で作っておく必要があるだろう。
	まずは普通に書いてうまく動くことを確認しよう。
* Text/Papillon/Parser.hs を git から外す
	これは papillon 自体がある程度安定してから、となるだろう。
* papillon command は何も取らなければ filter とする。
	また、papillon [Input] や papillon [Input] -o [Output] の形も使う。
	そのうちに papillon -h や papillon --help も。
	より使いやすく GetOpt を使ってみるのもいいかもしれない。
* 関数の名前について
	parser とかそういう名前は conflict するので、もっとちゃんとした名前にする
	...M という名前を使ったときに問題がある
* parser の呼び出しかたの改善
* haskell の exp をちゃんとパースしよう
	(...) を許すようにしよう
	3 + 2 とか x : xs とかを可能にしよう
	Maybe Int とかも
	変数のパターンも
* コメントを許すようにする
* 非終端記号に大文字で始まるものも許すようにしようかな
* 左再帰の解決はどうしようかな
	pappy はこれにひどく時間がかかっていた
* c:Char &{isDigit c} のような構造はどうなのだろうか
	けっこう使えるような気もするがもっときれいに書けないだろうか
	s[isHoge]:some のような感じはどうだろうか。
	そうすると今 s:[isHoge] となっているところは s[isHoge]:char
	ということになるだろう。
* ; を省略可能にしようかな
* msum を使うと error message が消えてしまうので何とかする必要がある
	つまり、msum はその一番右に Left "" を持っているということ。
	自分で msum1 を作る必要がある。
* module 構造について
	Papillon -+-> some
                  |
	papillon -+
	とすることで、Papillon が papillonStr 等を export せずにすむ。
	ただし、papillonStr を export するのが役立つ可能性もあるので考えること
* n:!... のときには n: の部分はいらないが、しかしそれだと、統一感がないな。
	_:!... とするか :!... とするか
* {-# LANGUAGE ... #-} がないときにはそれを追加する
* :some や :[...] を許すべきではないかもしれない。
	't' :hoge があまりうまくないな。
	':' の前後に空白を許さないようにすればいいのかもしれないが、
	どっちのほうが便利だろうか。
	嫌なバグを出さないのは :some をちゃんと _:some と書くほうだが。
	ただ、ここらへんの小さなシンプルさは使いやすさに影響するからな。
* source や token の見直し
	今の文法だと、source: SomeSource\ntoken: SomeToken のようになっているが
	今後より複雑な文法を許容した場合において ';' で区切ったほうが良いかもしれない
* !'c' のような形はどうするか
	つまり、!var:hoge のような形にするべきなのかもしれない。
	現在では var:!hoge のような形だが...
	これはけっこう大きな変更なので出来るだけ早く行う必要があるな。
* '\n' の形を読めるようにする。
	他は '\t', '\\', '\'' とか
