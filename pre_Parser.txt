{-# LANGUAGE PackageImports #-}

module Parser (
	Peg,
	Definition,
	NameLeaf,
	parse,
	dv_peg
) where

import GHC.Base
import GHC.Types
import Data.Char
import Control.Monad
import "monads-tf" Control.Monad.State.Class
import "transformers" Control.Monad.Trans.State.Lazy
import Data.Maybe
import Language.Haskell.TH

type Nil = ()
type Leaf = Either String ExR
type NameLeaf = (Name, Leaf)
type Expression = [NameLeaf]
type ExpressionHs = (Expression, ExR)
type Selection = [ExpressionHs]
type Typ = Name
type Definition = (String, Typ, Selection)
type Peg = [Definition]

type Ex = ExpQ -> ExpQ
type ExR = ExpQ

left :: b -> Either a b
right :: a -> Either a b
left = Right
right = Left

nil :: Nil
nil = ()

cons :: a -> [a] -> [a]
cons = (:)
mkNameLeaf :: String -> b -> (Name, b)
mkNameLeaf x y = (mkName x, y)
mkExpressionHs :: a -> Ex -> (a, ExR)
mkExpressionHs x y = (x, getEx y)
mkDef :: a -> String -> c -> (a, Name, c)
mkDef x y z = (x, mkName y, z)

toExp :: String -> Ex
toExp v = \f -> f `appE` varE (mkName v)

apply :: String -> Ex -> Ex
apply f x = \g -> x (toExp f g)

getEx :: Ex -> ExR
getEx ex = ex (varE $ mkName "id")

empty :: [a]
empty = []

isOpenBr, isCloseBr, isEqual, isSlash, isSemi,
	isColon, isOpenWave, isCloseWave, isLowerU :: Char -> Bool
isOpenBr = (== '[')
isCloseBr = (== ']')
isEqual = (== '=')
isSlash = (== '/')
isSemi = (== ';')
isColon = (== ':')
isOpenWave = (== '{')
isCloseWave = (== '}')
isLowerU c = isLower c || c == '_'

