{-# LANGUAGE FlexibleContexts, TemplateHaskell, UndecidableInstances,
	BangPatterns #-}

module Text.Papillon.Parser (
	Lookahead(..),
	Lists(..),

	Peg,
	Definition,
	Selection,
	Expression,
	PlainExpression,
	Check,
	ReadFrom(..),

	hsw,

	pprCheck,

	parse,
	Source(..),
	SourceList(..),
	Derivs(pegFile, peg, char),
	ParseError(..),
	mkParseError,
	pePositionS,
	Pos(..),
	ListPos(..),

	PPragma(..),
	ModuleName,
	Exports,
	Code,

	runError,

	dvCharsN
) where

import Language.Haskell.TH {- (
	Name, TypeQ, PatQ, ExpQ, mkName,
	conT, tupleT, listT, appT, arrowT,
	wildP, litP, varP, conP, tupP, listP, uInfixP,
	litE, varE, conE, tupE, listE, sigE, appE, infixE, uInfixE, lamE,
	integerL, charL, stringL) -}
import Data.Char (isDigit, isUpper, isLower, isAlphaNum)

import Language.Haskell.TH.PprLib
	((<>), hsep, colon, brackets, text, braces, Doc, parens, (<+>), quotes)
import qualified Language.Haskell.TH.PprLib as P
import Control.Arrow ((***))
import Data.List
import Data.Maybe

data Lookahead = Here | Ahead | NAhead String deriving (Show, Eq)
data Lists = List | List1 | Optional deriving (Show, Eq)

type PegFile = ([PPragma], ModuleName, Maybe Exports, Code, STPeg, Code)
data PPragma = LanguagePragma [String] | OtherPragma String deriving Show
type ModuleName = [String]
type Exports = String
type Code = String

type STPeg = (Maybe Type, Type, Peg)
type Peg = [Definition]
type Definition = (String, Maybe Type, Selection)
type Selection =  Either [Expression] [PlainExpression]
type Expression = Either ([(Lookahead, Check)], Maybe Exp) Exp
type PlainExpression = [(Lookahead, ReadFrom)]
type Check = Either ((Pat, String), ReadFrom, Maybe (Exp, String)) (Char, Lists)
data ReadFrom
	= FromVariable (Maybe String)
	| FromSelection Selection
	| FromL Lists ReadFrom
	deriving Show

pprCheck :: Check -> Doc
pprCheck (Left ((pt, _), rf, tst)) =
	ppr pt <> colon <> ppr rf <> maybe P.empty (brackets . ppr . fst) tst
pprCheck (Right (c, l)) = quotes (P.char c) <> ppr l

instance Ppr ReadFrom where
	ppr (FromVariable (Just v)) = text v
	ppr (FromVariable _) = P.empty
	ppr (FromL l rf) = ppr rf <> ppr l
	ppr (FromSelection sel) = parens $ ps sel
		where
		ps = hsep . intersperse (P.char '/') . either (map pe) (map ppe)
		pe (Left (ex, hs)) = (<+> braces (maybe P.empty ppr hs)) $ hsep $
			map (uncurry ($) . (((<>) . ppr) *** pprCheck)) ex
		pe (Right ex) = P.char '<' <> ppr ex <> P.char '>'
		ppe = hsep . map (uncurry (<>) . (ppr *** ppr))


instance Ppr Lookahead where
	ppr Here = P.empty
	ppr Ahead = P.char '&'
	ppr (NAhead _) = P.char '!'

instance Ppr Lists where
	ppr List = P.char '*'
	ppr List1 = P.char '+'
	ppr Optional = P.char '?'

mkPegFile :: [PPragma] -> Maybe ([String], Maybe String) -> String -> String ->
	STPeg -> String -> PegFile
mkPegFile ps (Just md) x y z w = (ps, fst md, snd md, x ++ "\n" ++ y, z, w)
mkPegFile ps Nothing x y z w = (ps, [], Nothing, x ++ "\n" ++ y, z, w)

dvCharsN :: String
dvCharsN = "char"

data Word
	= WTyp String
	| WVar String
	| WOp String
	| WOther String
	| WTypeDef
	| WColon
	| WOpenComment
	| WCloseComment
	| WOpenBracket
	| WCloseBracket
	| WOpenBrace
	| WCloseBrace
	| WOpenParen
	| WCloseParen
	| WAmp
	| WLT
	| WGT
	| WExclamation
	| WQuestion
	| WAsterisk
	| WPlus
	| WEquals
	| WHyphen
	| WSlash
	| WVerticalBar
	| WSemiColon
	| WOperator String
	| WVariable String
	| WInteger Integer
	| WType String
	| WOpenQuasiQuote String
	| WCloseQuasiQuote
	| WComma
	| WBackQuote
	| WRightArrow
	| WBackSlash
	| WModule
	| WWhere
	| WImport
	| WMonad
	| WSource
	| WChar Char
	| WString String
	| WSelectChars String
	| WDotDot
	deriving Show

isVarHead :: Char -> Bool
isVarHead = (||) <$> isLower <*> (== '_')

isVarTail :: Char -> Bool
isVarTail = or <$> sequence [isUpper, isLower, isDigit, (`elem` "_'")]

isOpChar :: Char -> Bool
isOpChar = (`elem` ":!#$%&*+./<=>?@\\^|-~")

[papillon|

monad: State (Maybe Int)

pegFile :: PegFile
	= pr:pragma* md:moduleDec pip:preImpPap _:importPapillon pp:prePeg
		(WOpenQuasiQuote "papillon"):hsw
		p:peg_ WCloseQuasiQuote:hsw atp:afterPeg
			{ return $ mkPegFile pr md pip pp p atp }
	/ pr:pragma* md:moduleDec pp:prePeg
		(WOpenQuasiQuote "papillon"):hsw
		p:peg_ WCloseQuasiQuote:hsw atp:afterPeg
			{ return $ mkPegFile pr md [] pp p atp }

pragma :: PPragma
	= WOpenComment:hsw (WType "LANGUAGE"):hsw s:pragmaItems WCloseComment:hsw
						{ return $ LanguagePragma s }
	/ WOpenComment:hsw s:pragmaStr WCloseComment:hsw
						{ return $ OtherPragma s }

pragmaStr :: String
	= !WCloseComment:hsw c s:pragmaStr	{ return $ c : s }
	/					{ return "" }

pragmaItems :: [String]
	= (WType t):hsw WComma:hsw i:pragmaItems{ return $ t : i }
	/ (WType t):hsw				{ return [t] }

moduleDec :: Maybe ([String], Maybe String)
	= WModule:hsw n:moduleName WOpenParen:hsw s:moduleDecStr _:whr
						{ return $ Just (n, Just s) }
	/ WModule:hsw n:moduleName WWhere:hsw
						{ return $ Just (n, Nothing) }
	/					{ return Nothing }

moduleName :: ModuleName
	= t:typ '.' n:moduleName		{ return $ t : n }
	/ (WType t):hsw				{ return [t] }

moduleDecStr :: String
	= !_:whr c s:moduleDecStr		{ return $ c : s }
	/					{ return "" }

whr :: () = WCloseParen:hsw WWhere:hsw

preImpPap :: String
	= !_:importPapillon !(WOpenQuasiQuote "papillon"):hsw c pip:preImpPap
						{ return $ c : pip }
	/					{ return "" }

prePeg :: String
	= !(WOpenQuasiQuote "papillon"):hsw c pp:prePeg
						{ return $ c : pp }
	/					{ return "" }

afterPeg :: String
	= c atp:afterPeg			{ return $ c : atp }
	/					{ return "" }

importPapillon :: ()
	= WImport:hsw "Text":typ '.' "Papillon":typ !'.'
						{ return () }

peg :: STPeg = _:space* p:peg_	{ return p }

peg_ :: STPeg = mt:monadType? st:sourceType? p:definition*
	{ return (mt, fromMaybe (ConT $ mkName "String") st, p) }

monadType :: Type
	= (!ListPos (CharPos (_, x))):position[put (Just x) >> return True]
		(WVar "monad"):word WColon:word t:hsTypeArr WSemiColon:word
						{ put Nothing >> return t }

sourceType :: Type
	= (!ListPos (CharPos (_, x))):position[put (Just x) >> return True]
		(WVar "source"):word WColon:word t:hsTypeArr WSemiColon:word
						{ put Nothing >> return t }

definition :: Definition
	= (!ListPos (CharPos (_, x))):position[put (Just x) >> return True]
		(WVar v):word
		mt:(WTypeDef:word t:hsTypeArr { return t })?
		WEquals:word sel:selection WSemiColon:word
		{ put Nothing >> return (v, mt, sel) }

selection :: Either [Expression] [PlainExpression]
	= ns:normalSelection			{ return $ Left ns }

normalSelection :: [Expression]
	= ex:expressionHs WSlash:word sel:normalSelection
						{ return $ ex : sel }
	/ ex:expressionHs			{ return [ex] }

expressionHs :: Expression
	= e:expression
		mh:(WOpenBrace:word h:hsExpLam WCloseBrace:word { return h })?
						{ return $ Left (e, mh) }
	/ e:expressionHsSugar			{ return e }

expressionHsSugar :: Expression
	= WLT:word h:hsExpLam WGT:word		{ return $ Right h }

expressionHsSugar' :: Expression
	= WLT:word h:hsExpLam' WGT:word		{ return $ Right h }

expression :: [(Lookahead, Check)]
	= l:nameLeaf_ e:expression		{ return $ l : e }
	/					{ return [] }

nameLeaf_ :: (Lookahead, Check)
	= WExclamation:word nl:nameLeafNoCom com:comForErr?
						{ return (NAhead $ maybe "" id com, nl) }
	/ WAmp:word nl:nameLeaf			{ return (Ahead, nl) }
	/ nl:nameLeaf				{ return (Here, nl) }

nameLeaf :: Check
	= cl:charLitLs				{ return cl }
	/ n:pat1 com:comForErr? WColon:word (rf, p):leaf
		{ return $ Left ((n, maybe "" id com), rf, p) }
	/ n:pat1 com:comForErr?
		{ return $ Left ((n, maybe "" id com), FromVariable Nothing, Nothing) }

nameLeafNoCom :: Check
	= cl:charLitLs				{ return cl }
	/ n:pat1 com:comForErr? WColon:word (rf, p):leaf
		{ return $ Left ((n, maybe "" id com), rf, p) }
	/ n:pat1{ return $ Left ((n, ""), FromVariable Nothing, Nothing) }

comForErr :: String
	= WOpenComment:word (WString s):word WCloseComment:word	{ return s }

leaf :: (ReadFrom, Maybe (Exp, String))
	= rf:readFromLs t:test			{ return (rf, Just t) }
	/ rf:readFromLs				{ return (rf, Nothing) }
	/ t:test				{ return (FromVariable Nothing,
							Just t) }

patOp :: Pat
	= p:pat o:opConName po:patOp		{ return $ UInfixP p o po }
	/ p:pat WBackQuote:hsw (WType t):hsw WBackQuote:hsw po:patOp
						{ return $ UInfixP p (mkName t) po }
	/ p:pat					{ return p }

pat :: Pat
	= (WType t):hsw ps:pats			{ return $ ConP (mkName t) ps }
	/ WOpenParen:hsw o:opConName WCloseParen:hsw ps:pats	{ return $ ConP o ps }
	/ p:pat1				{ return p }

pat1 :: Pat
	= (WType t):hsw				{ return $ ConP (mkName t) [] }
	/ (WVariable "_"):hsw			{ return WildP }
	/ (WVariable n):hsw			{ return $ VarP $ mkName n }
	/ (WInteger i):hsw			{ return $ LitP (IntegerL i) }
	/ WHyphen:hsw (WInteger i):hsw		{ return $ LitP (IntegerL $ - i) }
	/ (WChar c):hsw				{ return $ LitP $ CharL c }
	/ (WString s):hsw			{ return $ LitP $ StringL s }
	/ WOpenParen:hsw p:patList WCloseParen:hsw
						{ return $ TupP p }
	/ WOpenBracket:hsw p:patList WCloseBracket:hsw
						{ return $ ListP p }
	/ WOpenParen:hsw p:pat WCloseParen:hsw	{ return p }
	/ WExclamation:hsw p:pat		{ return $ BangP p }

patList :: [Pat]
	= p:patOp WComma:hsw ps:patList		{ return $ p : ps }
	/ p:patOp				{ return [p] }
	/					{ return [] }

opConName :: Name
	= ':' ot:opTail				{ return $ mkName $ ':' : ot }

pats :: [Pat]
	= p:pat ps:pats				{ return $ p : ps }
	/					{ return [] }

charLitLs :: Check
	= (WChar c):hsw WAsterisk:word			{ return $ Right (c, List) }
	/ (WChar c):hsw WPlus:word			{ return $ Right (c, List1) }
	/ (WChar c):hsw WQuestion:word			{ return $ Right (c, Optional) }

readFromLs :: ReadFrom
	= rf:readFrom WAsterisk:word			{ return $ FromL List rf }
	/ rf:readFrom WPlus:word			{ return $ FromL List1 rf }
	/ rf:readFrom WQuestion:word			{ return $ FromL Optional rf }
	/ rf:readFrom				{ return rf }

readFrom :: ReadFrom
	= (WVar v):word				{ return $ FromVariable $ Just v }
	/ WOpenParen:word s:selection WCloseParen:word		{ return $ FromSelection s }
	/ e:expressionHsSugar'			{ return $ FromSelection $ Left [e] }

test :: (Exp, String)
	= WOpenBracket:word h:hsExpLam com:comForErr? WCloseBracket:word
						{ return (h, maybe "" id com) }

hsExpLam :: Exp
	= WBackSlash:hsw ps:pats WRightArrow:hsw e:hsExpTyp{ return $ LamE ps e }
	/ e:hsExpTyp				{ return e }

hsExpTyp :: Exp
	= eo:hsExpOp WTypeDef:hsw t:hsTypeArr	{ return $ SigE eo t }
	/ eo:hsExpOp				{ return eo }

hsExpOp :: Exp
	= l:hsExp o:hsOp r:hsExpOp		{ return $ UInfixE (l id) o r }
	/ e:hsExp				{ return $ e id }

hsOp :: Exp
	= (WOperator op):hsw[return $ all isOpChar op && head op /= ':']
						{ return $ VarE $ mkName op }
	/ (WOperator op):hsw[return $ all isOpChar op && op /= "::"]
						{ return $ ConE $ mkName op }
	/ WBackQuote:hsw (WVariable v):hsw WBackQuote:hsw	
						{ return $ VarE $ mkName v }
	/ WBackQuote:hsw (WType t):hsw WBackQuote:hsw
						{ return $ ConE $ mkName t }


hsExpLam' :: Exp
	= WBackSlash:hsw ps:pats WRightArrow:hsw e:hsExpTyp'
						{ return $ LamE ps e }
	/ e:hsExpTyp'				{ return e }

hsExpTyp' :: Exp
	= eo:hsExpOp' WTypeDef:hsw t:hsTypeArr	{ return $ SigE eo t }
	/ eo:hsExpOp'				{ return eo }

hsExpOp' :: Exp
	= l:hsExp o:hsOp' r:hsExpOp'		{ return $ UInfixE (l id) o r }
	/ e:hsExp				{ return $ e id }

hsOp' :: Exp
	= (WOperator op):hsw[return $ all isOpChar op && head op /= ':' && head op /= '>']
						{ return $ VarE $ mkName op }
	/ (WOperator op):hsw[return $ all isOpChar op && op /= "::" && head op /= '>']
						{ return $ ConE $ mkName op }
	/ WBackQuote:hsw v:var WBackQuote:hsw		{ return $ VarE $ mkName v }
	/ WBackQuote:hsw t:typ WBackQuote:hsw		{ return $ ConE $ mkName t }

opTail :: String
	= c:<(`elem` ":+*/-!|&.^=<>$")> s:opTail{ return $ c : s }
	/					{ return "" }

hsExp :: (Exp -> Exp) -> Exp
	= e:hsExp1 h:hsExp			{return (\f->h (f e `AppE`))}
	/ e:hsExp1				{return (\f->f e)}

hsExp1 :: Exp
	= WOpenParen:hsw l:hsExpOp? o:hsOp r:hsExpOp? WCloseParen:hsw
						{ return $ InfixE l o r }
	/ WOpenParen:hsw et:hsExpTpl WCloseParen:hsw
						{ return $ TupE et }
	/ WOpenBracket:hsw et:hsExpTpl WCloseBracket:hsw
						{ return $ ListE et }
	/ WOpenBracket:hsw b:hsExpOp WDotDot:hsw e:hsExpOp WCloseBracket:hsw
						{ return $ ArithSeqE $ FromToR b e }
	/ (WVariable v):hsw			{ return $ VarE $ mkName v }
	/ (WType t):hsw				{ return $ ConE $ mkName t }
	/ (WInteger i):hsw			{ return $ LitE $ integerL i }
	/ (WChar c):hsw				{ return $ LitE $ charL c }
	/ (WString s):hsw			{ return $ LitE $ stringL s }
	/ WHyphen:hsw e:hsExp1			{ return $ AppE (VarE $ mkName "negate") e }

hsExpTpl :: [Exp]
	= e:hsExpLam WComma:hsw et:hsExpTpl
						{ return $ e : et }
	/ e:hsExpLam				{ return [e] }
	/					{ return [] }

hsTypeArr :: Type
	= l:hsType WRightArrow:hsw r:hsTypeArr	{ return $ AppT (AppT ArrowT $ l id) r }
	/ t:hsType				{ return $ t id }

hsType :: (Type -> Type) -> Type
	= t:hsType1 ts:hsType			{ return $(\f -> ts (f t `AppT`)) }
	/ t:hsType1				{ return ($ t) }

hsType1 :: Type
	= WOpenBracket:hsw WCloseBracket:hsw	{ return ListT }
	/ WOpenBracket:hsw t:hsTypeArr WCloseBracket:hsw
						{ return $ ListT `AppT` t }
	/ WOpenParen:hsw tt:hsTypeTpl WCloseParen:hsw
						{ return $ foldl AppT
							(TupleT $ length tt) tt }
	/ (WType t):hsw				{ return $ ConT $ mkName t }
	/ WOpenParen:hsw WRightArrow:hsw WCloseParen:hsw
						{ return ArrowT }

hsTypeTpl :: [Type]
	= t:hsTypeArr WComma:hsw tt:hsTypeTpl	{ return $ t : tt }
	/ t:hsTypeArr				{ return [t] }
	/					{ return [] }

typ :: String = u:<isUpper> t:<isVarTail>*	{ return $ u : t }
var :: String = l:<isVarHead> t:<isVarTail>*	{ return $ l : t }

word :: Word
	= t:typ _:space*			{ return $ WTyp t }
	/ v:var _:space*			{ return $ WVar v }
	/ w:<isAlphaNum>+ _:space*		{ return $ WOther w }
	/ ':' ':' _:space*			{ return WTypeDef }
	/ ':' _:space*				{ return WColon }
	/ '{' '-' '#' _:space*			{ return WOpenComment }
	/ '#' '-' '}' _:space*			{ return WCloseComment }

	-- ":&!?*+[]{}<=>()-/|;"
	/ '[' _:space*				{ return WOpenBracket }
	/ ']' _:space*				{ return WCloseBracket }
	/ '{' _:space*				{ return WOpenBrace }
	/ '}' _:space*				{ return WCloseBrace }
	/ '(' _:space*				{ return WOpenParen }
	/ ')' _:space*				{ return WCloseParen }
	/ '&' _:space*				{ return WAmp }
	/ '<' _:space*				{ return WLT }
	/ '>' _:space*				{ return WGT }
	/ '!' _:space*				{ return WExclamation }
	/ '?' _:space*				{ return WQuestion }
	/ '*' _:space*				{ return WAsterisk }
	/ '+' _:space*				{ return WPlus }
	/ '=' _:space*				{ return WEquals }
	/ '-' !'-' _:space*			{ return WHyphen }
	/ '/' _:space*				{ return WSlash }
	/ '|' _:space*				{ return WVerticalBar }
	/ _:semiColon _:space'*			{ return WSemiColon}
	/ '\'' c:<(`notElem` "\\'")> '\'' _:space*
						{ return $ WChar c }
	/ '\'' '\\' c:escapeC '\'' _:space*	{ return $ WChar c }
	/ '"' s:stringLit_ '"' _:space*		{ return $ WString s }

hsw :: Word
	= 'm' 'o' 'd' 'u' 'l' 'e' _:space*	{ return $ WModule }
	/ 'w' 'h' 'e' 'r' 'e' _:space*		{ return $ WWhere }
	/ 'i' 'm' 'p' 'o' 'r' 't' _:space*	{ return $ WImport }
	/ t:typ _:space*			{ return $ WType t }
	/ v:var _:space*			{ return $ WVariable v }
	/ d:<isDigit>+ _:space*			{ return $ WInteger $ read d }
	/ w:<isAlphaNum>+ _:space*		{ return $ WOther w }
	/ '[' v:var '|' _:space*		{ return $ WOpenQuasiQuote v }
	/ '|' ']' _:space*			{ return WCloseQuasiQuote }
	/ '-' '>' _:space*			{ return WRightArrow }
	/ ':' ':' _:space*			{ return WTypeDef }
	/ '{' '-' '#' _:space*			{ return WOpenComment }
	/ '#' '-' '}' _:space*			{ return WCloseComment }
	/ '.' '.' _:space*			{ return WDotDot }
	/ '[' _:space*				{ return WOpenBracket }
	/ ']' _:space*				{ return WCloseBracket }
	/ '{' _:space*				{ return WOpenBrace }
	/ '}' _:space*				{ return WCloseBrace }
	/ '(' _:space*				{ return WOpenParen }
	/ ')' _:space*				{ return WCloseParen }
	/ ',' _:space*				{ return WComma }
	/ '`' _:space*				{ return WBackQuote }
	/ '-' !'-' _:space*			{ return WHyphen }
	/ '!' _:space*				{ return WExclamation }
	/ '\\' _:space*				{ return WBackSlash }
	/ w:<isOpChar>+ _:space*		{ return $ WOperator w }
	/ '\'' c:<(`notElem` "\\'")> '\'' _:space*
						{ return $ WChar c }
	/ '\'' '\\' c:escapeC '\'' _:space*	{ return $ WChar c }
	/ '"' s:stringLit_ '"' _:space*		{ return $ WString s }

stringLit_ :: String
	= c:<(`notElem` "\"\\")> s:stringLit_	{ return $ c : s }
	/ '\\' c:escapeC s:stringLit_		{ return $ c : s }
	/					{ return "" }

escapeC :: Char
	= '"'					{ return '"' }
	/ '\''					{ return '\'' }
	/ '\\'					{ return '\\' }
	/ 'n'					{ return '\n' }
	/ 't'					{ return '\t' }

space :: ()
	= s:[return $ s `elem` " \t"]		{ return () }
	/ _:notSemiColon			{ return () }
	/ _:lineComment				{ return () }
	/ _:comment				{ return () }

space' :: ()
	= s:[return $ s `elem` " \t"]		{ return () }
	/ _:newLine				{ return () }
	/ _:lineComment				{ return () }
	/ _:comment				{ return () }

lineComment :: () = '-' '-' _:notNLString &'\n'	{ return () }

notNLString :: String
	= !'\n' c s:notNLString			{ return $ c : s }
	/					{ return "" }

comment :: ()
	= '{' '-' !'#' _:comments _:comEnd	{ return () }

comments :: ()
	= _:notComStr _:comment _:comments	{ return () }
	/ _:notComStr				{ return () }

notComStr :: ()
	= !_:comment !_:comEnd _ _:notComStr	{ return () }
	/					{ return () }

comEnd = '-' '}'

semiColon
	= ';'					{ return () }
	/ _:newLine _:('\t' / ' ')*
		(!ListPos (CharPos (_, h))):position[get>>=
			(\b -> return $ maybe False (>=h) b)]
		!_:lineComment !_:comment !';'
						{ return () }
	/ !_:[return True]			{ return () }

notSemiColon
	= _:newLine _:('\t' / ' ')*
		(!ListPos (CharPos (_, h))):position[get>>=
			(\b -> return $ maybe True (< h) b)]
	/ _:newLine _:lineComment
	/ _:newLine _:comment
	/ _:newLine &';'

newLine = '\n'+

|]
