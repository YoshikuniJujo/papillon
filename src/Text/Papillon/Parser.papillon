{-# LANGUAGE FlexibleContexts, TemplateHaskell, UndecidableInstances,
	BangPatterns #-}

module Text.Papillon.Parser (
	Lookahead(..),
	Lists(..),

	Peg,
	Definition,
	Selection,
	Expression,
	PlainExpression,
	Check,
	ReadFrom(..),

	pprCheck,

	parse,
	Source(..),
	SourceList(..),
	Derivs(pegFile, peg, char),
	ParseError(..),
	mkParseError,
	pePositionS,
	Pos(..),
	ListPos(..),

	PPragma(..),
	ModuleName,
	Exports,
	Code,

	runError,

	dvCharsN
) where

import Language.Haskell.TH {- (
	Name, TypeQ, PatQ, ExpQ, mkName,
	conT, tupleT, listT, appT, arrowT,
	wildP, litP, varP, conP, tupP, listP, uInfixP,
	litE, varE, conE, tupE, listE, sigE, appE, infixE, uInfixE, lamE,
	integerL, charL, stringL) -}
import Data.Char (isSpace, isDigit, isUpper, isLower, isAlphaNum)

import Language.Haskell.TH.PprLib
	((<>), hsep, colon, brackets, text, braces, Doc, parens, (<+>), quotes)
import qualified Language.Haskell.TH.PprLib as P
import Control.Arrow ((***))
import Data.List
-- import Data.Maybe

data Lookahead = Here | Ahead | NAhead String deriving (Show, Eq)
data Lists = List | List1 | Optional deriving (Show, Eq)

type PegFile = ([PPragma], ModuleName, Maybe Exports, Code, STPeg, Code)
data PPragma = LanguagePragma [String] | OtherPragma String deriving Show
type ModuleName = [String]
type Exports = String
type Code = String

type STPeg = (Maybe Type, Type, Peg)
type Peg = [Definition]
type Definition = (String, Maybe Type, Selection)
type Selection =  Either [Expression] [PlainExpression]
type Expression = Either ([(Lookahead, Check)], Exp) Exp
type PlainExpression = [(Lookahead, ReadFrom)]
type Check = Either ((Pat, String), ReadFrom, Maybe (Exp, String)) (Char, Lists)
data ReadFrom
	= FromVariable (Maybe String)
	| FromSelection Selection
	| FromL Lists ReadFrom
	deriving Show

pprCheck :: Check -> Doc
pprCheck (Left ((pt, _), rf, tst)) =
	ppr pt <> colon <> ppr rf <> maybe P.empty (brackets . ppr . fst) tst
pprCheck (Right (c, l)) = quotes (P.char c) <> ppr l

instance Ppr ReadFrom where
	ppr (FromVariable (Just v)) = text v
	ppr (FromVariable _) = P.empty
	ppr (FromL l rf) = ppr rf <> ppr l
	ppr (FromSelection sel) = parens $ ps sel
		where
		ps = hsep . intersperse (P.char '/') . either (map pe) (map ppe)
		pe (Left (ex, hs)) = (<+> braces (ppr hs)) $ hsep $
			map (uncurry ($) . (((<>) . ppr) *** pprCheck)) ex
		pe (Right ex) = P.char '<' <> ppr ex <> P.char '>'
		ppe = hsep . map (uncurry (<>) . (ppr *** ppr))


instance Ppr Lookahead where
	ppr Here = P.empty
	ppr Ahead = P.char '&'
	ppr (NAhead _) = P.char '!'

instance Ppr Lists where
	ppr List = P.char '*'
	ppr List1 = P.char '+'
	ppr Optional = P.char '?'

mkPegFile :: [PPragma] -> Maybe ([String], Maybe String) -> String -> String ->
	STPeg -> String -> PegFile
mkPegFile ps (Just md) x y z w = (ps, fst md, snd md, x ++ "\n" ++ y, z, w)
mkPegFile ps Nothing x y z w = (ps, [], Nothing, x ++ "\n" ++ y, z, w)

charList :: String -> ReadFrom
charList cs = FromSelection $ Left $ (: []) $ Right $
	InfixE Nothing (VarE $ mkName "elem") $ Just $ LitE $ StringL cs

dvCharsN :: String
dvCharsN = "char"

data Word
	= WTyp String
	| WVar String
	| WOp String
	| WTypeDef
	| WColon
	| WOpenComment
	| WCloseComment
	| WOpenBracket
	| WCloseBracket
	| WOpenBrace
	| WCloseBrace
	| WOpenParen
	| WCloseParen
	| WAmp
	| WLT
	| WGT
	| WExclamation
	| WQuestion
	| WAsterisk
	| WPlus
	| WEquals
	| WHyphen
	| WSlash
	| WVerticalBar
	| WSemiColon
	deriving Show

isVarHead :: Char -> Bool
isVarHead = (||) <$> isLower <*> (== '_')

isVarTail :: Char -> Bool
isVarTail = or <$> sequence [isUpper, isLower, isDigit, (`elem` "_'")]

isOpChar :: Char -> Bool
isOpChar = (`elem` ":!#$%&*+./<=>?@\\^|-~")

isSepChar :: Char -> Bool
isSepChar = (`elem` "(),;[]`{}_:")

[papillon|

monad: State (Maybe Int)

pegFile :: PegFile
	= pr:pragmas md:moduleDec pip:preImpPap _:importPapillon pp:prePeg _:pap
		_:spaces' p:peg' _:spaces' '|' ']' '\n' atp:afterPeg
			{ return $ mkPegFile pr md pip pp p atp }
	/ pr:pragmas md:moduleDec pp:prePeg _:pap _:spaces' p:peg' _:spaces'
		'|' ']' '\n' atp:afterPeg
			{ return $ mkPegFile pr md [] pp p atp }

pragmas :: [PPragma]
	= _:spaces' pr:pragma prs:pragmas	{ return $ pr : prs }
	/ _:spaces'				{ return [] }

pragma :: PPragma
	= WOpenComment:word 'L' 'A' 'N' 'G' 'U' 'A' 'G' 'E' _:spaces'
		s:pragmaItems _:pragmaEnd	{ return $ LanguagePragma s }
	/ WOpenComment:word s:pragmaStr _:pragmaEnd	{ return $ OtherPragma s }

pragmaStr :: String
	= !_:pragmaEnd c s:pragmaStr		{ return $ c : s }
	/					{ return "" }

pragmaItems :: [String]
	= (WTyp t):word ",":hsw i:pragmaItems	{ return $ t : i }
	/ (WTyp t):word				{ return [t] }

pragmaEnd :: ()
	= _:spaces' WCloseComment:word		{ return () }

moduleDec :: Maybe ([String], Maybe String)
	= (WVar "module"):word n:moduleName WOpenParen:word s:moduleDecStr _:whr
						{ return $ Just (n, Just s) }
	/ (WVar "module"):word n:moduleName (WVar "where"):word
						{ return $ Just (n, Nothing) }
	/					{ return Nothing }

moduleName :: ModuleName
	= t:typ '.' n:moduleName		{ return $ t : n }
	/ (WTyp t):word				{ return [t] }

moduleDecStr :: String
	= !_:whr c s:moduleDecStr		{ return $ c : s }
	/					{ return "" }

whr :: () = _:spaces' WCloseParen:word (WVar "where"):word	{ return () }

preImpPap :: String
	= !_:importPapillon !_:pap c pip:preImpPap
						{ return $ c : pip }
	/					{ return "" }

prePeg :: String
	= !_:pap c pp:prePeg			{ return $ c : pp }
	/					{ return "" }

afterPeg :: String
	= c atp:afterPeg			{ return $ c : atp }
	/					{ return "" }

importPapillon :: ()
	= "import":varWord "Text":typ '.' "Papillon":typ !'.'
						{ return () }

pap :: () = '\n' WOpenBracket:word (WVar "papillon"):word WVerticalBar:word '\n'
						{ return () }

peg :: STPeg = _:spaces _:spaces' p:peg'	{ return p }

peg' :: STPeg
	= mt:monadType? s:sourceType p:peg_	{ return (mt, ConT $
							mkName s, p) }
	/ mt:monadType? p:peg_			{ return (mt, ConT $
							mkName "String", p) }

monadType :: Type
	= (!ListPos (CharPos (_, x))):position[put (Just x) >> return True]
		(WVar "monad"):word WColon:word t:hsTypeArr WSemiColon:word
						{ put Nothing >> return t }

sourceType :: String
	= (!ListPos (CharPos (_, x))):position[put (Just x) >> return True]
		(WVar "source"):word WColon:word (WTyp v):word WSemiColon:word
						{ put Nothing >> return v }

peg_ :: Peg
	= d:definition p:peg_			{ return $ d : p }
	/ 					{ return [] }

definition :: Definition
	= (!ListPos (CharPos (_, x))):position[put (Just x) >> return True]
		v:varWord WTypeDef:word t:hsTypeArr WEquals:word sel:selection
			WSemiColon:word
		{ put Nothing >> return (v, Just t, sel) }
	/ (!ListPos (CharPos (_, x))):position[put (Just x) >> return True]
		v:varWord WEquals:word sel:plainSelection WSemiColon:word
		{ put Nothing >> return (v, Nothing, Right sel) }

selection = normalSelection / plainSelection

normalSelection :: [Expression]
	= ex:expressionHs WSlash:word sel:normalSelection
						{ return $ ex : sel }
	/ ex:expressionHs			{ return [ex] }

plainSelection :: [PlainExpression]
	= ex:plainExpressionHs WSlash:word sel:plainSelection
						{ return $ ex : sel }
	/ ex:plainExpressionHs			{ return [ex] }

expressionHs :: Expression
	= e:expression WOpenBrace:word h:hsExpLam WCloseBrace:word
						{ return $ Left (e, h) }
	/ e:expressionHsSugar			{ return e }

expressionHsSugar :: Expression
	= WLT:word h:hsExpLam WGT:word		{ return $ Right h }

expressionHsSugar' :: Expression
	= WLT:word h:hsExpLam' WGT:word		{ return $ Right h }

plainExpressionHs :: PlainExpression
	= rfs:(rf:plainHAReadFromLs { return rf })*	{ return rfs }

plainHAReadFromLs :: (Lookahead, ReadFrom)
	= rf:plainReadFromLs			{ return (Here, rf) }
	/ '&' rf:plainReadFromLs		{ return (Ahead, rf) }
	/ '!' rf:plainReadFromLs		{ return (NAhead "", rf) }

plainReadFromLs :: ReadFrom
	= rf:readFromLs				{ return rf }
	/ rf:selectCharsLs			{ return rf }

expression :: [(Lookahead, Check)]
	= l:nameLeaf_ e:expression		{ return $ l : e }
	/					{ return [] }

nameLeaf_ :: (Lookahead, Check)
	= WExclamation:word nl:nameLeafNoCom com:comForErr?
						{ return (NAhead $ maybe "" id com, nl) }
	/ WAmp:word nl:nameLeaf			{ return (Ahead, nl) }
	/ nl:nameLeaf				{ return (Here, nl) }

nameLeaf :: Check
	= cl:charLitLs				{ return cl }
	/ n:pat1 com:comForErr? WColon:word (rf, p):leaf
		{ return $ Left ((n, maybe "" id com), rf, p) }
	/ n:pat1 com:comForErr?
		{ return $ Left ((n, maybe "" id com), FromVariable Nothing, Nothing) }

nameLeafNoCom :: Check
	= cl:charLitLs				{ return cl }
	/ n:pat1 com:comForErr? WColon:word (rf, p):leaf
		{ return $ Left ((n, maybe "" id com), rf, p) }
	/ n:pat1{ return $ Left ((n, ""), FromVariable Nothing, Nothing) }

comForErr :: String
	= WOpenComment:word s:stringLit WCloseComment:word	{ return s }

leaf :: (ReadFrom, Maybe (Exp, String))
	= rf:readFromLs t:test			{ return (rf, Just t) }
	/ rf:readFromLs				{ return (rf, Nothing) }
	/ t:test				{ return (FromVariable Nothing,
							Just t) }

patOp :: Pat
	= p:pat o:opConName po:patOp		{ return $ UInfixP p o po }
	/ p:pat "`":hsw (WTyp t):word "`":hsw po:patOp
						{ return $ UInfixP p (mkName t) po }
	/ p:pat					{ return p }

pat :: Pat
	= (WTyp t):word ps:pats			{ return $ ConP (mkName t) ps }
	/ "(":hsw o:opConName ")":hsw ps:pats	{ return $ ConP o ps }
	/ p:pat1				{ return p }

pat1 :: Pat
	= (WTyp t):word			{ return $ ConP (mkName t) [] }
	/ "_":hsw				{ return WildP }
	/ n:varWord				{ return $ VarP $ mkName n }
	/ i:integer				{ return $ LitP (IntegerL i) }
	/ "-":hsw i:integer			{ return $ LitP (IntegerL $ - i) }
	/ c:charLit 				{ return $ LitP $ CharL c }
	/ s:stringLit				{ return $ LitP $ StringL s }
	/ "(":hsw p:patList ")":hsw		{ return $ TupP p }
	/ "[":hsw p:patList "]":hsw		{ return $ ListP p }
	/ "(":hsw p:pat ")":hsw			{ return p }
	/ "!":hsw p:pat				{ return $ BangP p }

patList :: [Pat]
	= p:patOp ",":hsw ps:patList		{ return $ p : ps }
	/ p:patOp				{ return [p] }
	/					{ return [] }

opConName :: Name
	= ':' ot:opTail				{ return $ mkName $ ':' : ot }

pats :: [Pat]
	= p:pat ps:pats				{ return $ p : ps }
	/					{ return [] }

charLitLs :: Check
	= c:charLit WAsterisk:word			{ return $ Right (c, List) }
	/ c:charLit WPlus:word			{ return $ Right (c, List1) }
	/ c:charLit WQuestion:word			{ return $ Right (c, Optional) }

readFromLs :: ReadFrom
	= rf:readFrom WAsterisk:word			{ return $ FromL List rf }
	/ rf:readFrom WPlus:word			{ return $ FromL List1 rf }
	/ rf:readFrom WQuestion:word			{ return $ FromL Optional rf }
	/ rf:readFrom				{ return rf }

readFrom :: ReadFrom
	= v:varWord				{ return $ FromVariable $ Just v }
	/ WOpenParen:word s:selection WCloseParen:word		{ return $ FromSelection s }
	/ e:expressionHsSugar'			{ return $ FromSelection $ Left [e] }

selectCharsLs :: ReadFrom
	= rf:selectChars WAsterisk:word		{ return $ FromL List rf }
	/ rf:selectChars WPlus:word		{ return $ FromL List1 rf }
	/ rf:selectChars WQuestion:word		{ return $ FromL Optional rf }
	/ rf:selectChars			{ return rf }

selectChars :: ReadFrom
	= WOpenBracket:word cs:<(`notElem` "\\-")>+ WCloseBracket:word
						{ return $ charList cs }
	/ WOpenBracket:word cb:<(`notElem` "\\-")> WHyphen:word
		ce:<(`notElem` "\\-")> WCloseBracket:word
						{ return $ charList [cb .. ce] }
--	/ '\'' c:<(`notElem` "\\'")> '\''	{ return $ charList [c] }
	/ c:charLit				{ return $ charList [c] }

test :: (Exp, String)
	= WOpenBracket:word h:hsExpLam com:comForErr? WCloseBracket:word
						{ return (h, maybe "" id com) }

hsExpLam :: Exp
	= "\\":hsw ps:pats "->":hsw e:hsExpTyp{ return $ LamE ps e }
	/ e:hsExpTyp				{ return e }

hsExpTyp :: Exp
	= eo:hsExpOp "::":hsw t:hsTypeArr	{ return $ SigE eo t }
	/ eo:hsExpOp				{ return eo }

hsExpOp :: Exp
	= l:hsExp o:hsOp r:hsExpOp		{ return $ UInfixE (l id) o r }
	/ e:hsExp				{ return $ e id }

hsOp :: Exp
	= op:hsw[return $ all isOpChar op && head op /= ':']
						{ return $ VarE $ mkName op }
	/ op:hsw[return $ all isOpChar op && op /= "::"]
						{ return $ ConE $ mkName op }
	/ "`":hsw v:varWord "`":hsw		{ return $ VarE $ mkName v }
	/ "`":hsw (WTyp t):word "`":hsw	{ return $ ConE $ mkName t }


hsExpLam' :: Exp
	= "\\":hsw ps:pats "->":hsw e:hsExpTyp'
						{ return $ LamE ps e }
	/ e:hsExpTyp'				{ return e }

hsExpTyp' :: Exp
	= eo:hsExpOp' "::":hsw t:hsTypeArr	{ return $ SigE eo t }
	/ eo:hsExpOp'				{ return eo }

hsExpOp' :: Exp
	= l:hsExp o:hsOp' r:hsExpOp'		{ return $ UInfixE (l id) o r }
	/ e:hsExp				{ return $ e id }

hsOp' :: Exp
	= op:hsw[return $ all isOpChar op && head op /= ':' && head op /= '>']
						{ return $ VarE $ mkName op }
	/ op:hsw[return $ all isOpChar op && op /= "::" && head op /= '>']
						{ return $ ConE $ mkName op }
	/ "`":hsw v:var "`":hsw		{ return $ VarE $ mkName v }
	/ "`":hsw t:typ "`":hsw		{ return $ ConE $ mkName t }

opTail :: String
	= c:<(`elem` ":+*/-!|&.^=<>$")> s:opTail{ return $ c : s }
	/					{ return "" }

hsExp :: (Exp -> Exp) -> Exp
	= e:hsExp1 h:hsExp			{return (\f->h (f e `AppE`))}
	/ e:hsExp1				{return (\f->f e)}

hsExp1 :: Exp
	= "(":hsw l:hsExpOp? o:hsOp r:hsExpOp? ")":hsw
						{ return $ InfixE l o r }
	/ "(":hsw et:hsExpTpl ")":hsw		{ return $ TupE et }
	/ "[":hsw et:hsExpTpl "]":hsw		{ return $ ListE et }
	/ v:varWord				{ return $ VarE $ mkName v }
	/ (WTyp t):word			{ return $ ConE $ mkName t }
	/ i:integer				{ return $ LitE $ integerL i }
	/ c:charLit				{ return $ LitE $ charL c }
	/ s:stringLit				{ return $ LitE $ stringL s }
	/ "-":hsw e:hsExp1			{ return $ AppE (VarE $ mkName "negate") e }

hsExpTpl :: [Exp]
	= e:hsExpLam ",":hsw et:hsExpTpl
						{ return $ e : et }
	/ e:hsExpLam				{ return [e] }
	/					{ return [] }

hsTypeArr :: Type
	= l:hsType "->":hsw r:hsTypeArr	{ return $ AppT (AppT ArrowT $ l id) r }
	/ t:hsType				{ return $ t id }

hsType :: (Type -> Type) -> Type
	= t:hsType1 ts:hsType			{ return $(\f -> ts (f t `AppT`)) }
	/ t:hsType1				{ return ($ t) }

hsType1 :: Type
	= "[":hsw "]":hsw			{ return ListT }
	/ "[":hsw t:hsTypeArr "]":hsw		{ return $ ListT `AppT` t }
	/ "(":hsw tt:hsTypeTpl ")":hsw		{ return $ foldl AppT
							(TupleT $ length tt) tt }
	/ (WTyp t):word			{ return $ ConT $ mkName t }
	/ "(":hsw "->":hsw ")":hsw		{ return ArrowT }

hsTypeTpl :: [Type]
	= t:hsTypeArr ",":hsw tt:hsTypeTpl	{ return $ t : tt }
	/ t:hsTypeArr				{ return [t] }
	/					{ return [] }

integer :: Integer = ds:hsw[return $ all isDigit ds]
						{ return $ read $ ds }

varWord :: String = v:var _:spaces		{ return v }

typ :: String = u:<isUpper> t:<isVarTail>*	{ return $ u : t }
var :: String = l:<isVarHead> t:<isVarTail>*	{ return $ l : t }

word :: Word
	= t:typ _:spaces			{ return $ WTyp t }
	/ v:var _:spaces			{ return $ WVar v }
	/ w:<isAlphaNum>+ _:spaces		{ return $ WVar w }
	/ ':' ':' _:spaces			{ return WTypeDef }
	/ ':' _:spaces				{ return WColon }
	/ '{' '-' '#' _:spaces			{ return WOpenComment }
	/ '#' '-' '}' _:spaces			{ return WCloseComment }

	-- ":&!?*+[]{}<=>()-/|;"
	/ '[' _:spaces				{ return WOpenBracket }
	/ ']' _:spaces				{ return WCloseBracket }
	/ '{' _:spaces				{ return WOpenBrace }
	/ '}' _:spaces				{ return WCloseBrace }
	/ '(' _:spaces				{ return WOpenParen }
	/ ')' _:spaces				{ return WCloseParen }
	/ '&' _:spaces				{ return WAmp }
	/ '<' _:spaces				{ return WLT }
	/ '>' _:spaces				{ return WGT }
	/ '!' _:spaces				{ return WExclamation }
	/ '?' _:spaces				{ return WQuestion }
	/ '*' _:spaces				{ return WAsterisk }
	/ '+' _:spaces				{ return WPlus }
	/ '=' _:spaces				{ return WEquals }
	/ '-' _:spaces				{ return WHyphen }
	/ '/' _:spaces				{ return WSlash }
	/ '|' _:spaces				{ return WVerticalBar }
	/ _:semiColon _:spaces			{ return WSemiColon}

hsw :: String
	= w:<isAlphaNum>+ _:spaces		{ return w }
	/ '|' ']' _:spaces			{ return "|]" }
	/ w:<isOpChar>+ _:spaces		{ return w }
	/ w:<isSepChar> _:spaces		{ return [w] }

charLit :: Char
	= '\'' c:<(`notElem` "\\'")> '\'' _:spaces	{ return c }
	/ '\'' '\\' c:escapeC '\'' _:spaces	{ return c }

stringLit :: String
	= '"' s:stringLit_ '"' _:spaces		{ return s }

stringLit_ :: String
	= c:<(`notElem` "\"\\")> s:stringLit_	{ return $ c : s }
	/ '\\' c:escapeC s:stringLit_		{ return $ c : s }
	/					{ return "" }

escapeC :: Char
	= '"'					{ return '"' }
	/ '\''					{ return '\'' }
	/ '\\'					{ return '\\' }
	/ 'n'					{ return '\n' }
	/ 't'					{ return '\t' }

spaces' :: () = _:<isSpace>*			{ return () }

spaces :: ()
	= _:space _:spaces			{ return () }
	/ 					{ return () }

space :: ()
	= s:[return $ s `elem` " \t"]		{ return () }
	/ _:notSemiColon			{ return () }
	/ _:lineComment				{ return () }
	/ _:comment				{ return () }

lineComment :: () = '-' '-' _:notNLString &'\n'	{ return () }

notNLString :: String
	= !'\n' c s:notNLString			{ return $ c : s }
	/					{ return "" }

comment :: ()
	= '{' '-' !'#' _:comments _:comEnd	{ return () }

comments :: ()
	= _:notComStr _:comment _:comments	{ return () }
	/ _:notComStr				{ return () }

notComStr :: ()
	= !_:comment !_:comEnd _ _:notComStr	{ return () }
	/					{ return () }

comEnd :: ()
	= '-' '}'				{ return () }

-- semi :: () = _:semiColon _:spaces		{ put Nothing }

semiColon :: ()
	= ';' _:newLine?			{ return () }
	/ _:newLine _:headSpace*
		(!ListPos (CharPos (_, h))):position[get>>=
			(\b -> return $ maybe False (>=h) b)]
		!_:lineComment !_:comment !';'
						{ return () }
	/ !_:[return True]			{ return () }

notSemiColon :: ()
	= _:newLine _:headSpace
		(!ListPos (CharPos (_, h))):position[get>>=
			(\b -> return $ maybe True (< h) b)]
						{ return () }
	/ _:newLine _:lineComment		{ return () }
	/ _:newLine _:comment			{ return () }
	/ _:newLine &';'			{ return () }

newLine :: () = '\n'+				{ return () }

headSpace :: () = '\t' { return () } / ' ' { return () }

|]
