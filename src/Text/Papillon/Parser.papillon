{-# LANGUAGE FlexibleContexts, TemplateHaskell, UndecidableInstances,
	BangPatterns #-}

module Text.Papillon.Parser (
	Lookahead(..),
	Lists(..),

	Peg,
	Definition,
	Selection,
	Expression,
	PlainExpression,
	Check,
	ReadFrom(..),

	pprCheck,

	parse,
	Source(..),
	SourceList(..),
	Derivs(pegFile, peg, char),
	ParseError(..),
	mkParseError,
	pePositionS,
	Pos(..),
	ListPos(..),

	PPragma(..),
	ModuleName,
	Exports,
	Code,

	runError,

	dvCharsN
) where

import Language.Haskell.TH {- (
	Name, TypeQ, PatQ, ExpQ, mkName,
	conT, tupleT, listT, appT, arrowT,
	wildP, litP, varP, conP, tupP, listP, uInfixP,
	litE, varE, conE, tupE, listE, sigE, appE, infixE, uInfixE, lamE,
	integerL, charL, stringL) -}
import Data.Char (isSpace, isDigit, isUpper, isLower, isAlphaNum)

import Language.Haskell.TH.PprLib
	((<>), hsep, colon, brackets, text, braces, Doc, parens, (<+>), quotes)
import qualified Language.Haskell.TH.PprLib as P
import Control.Arrow ((***))
import Data.List
-- import Data.Maybe

data Lookahead = Here | Ahead | NAhead String deriving (Show, Eq)
data Lists = List | List1 | Optional deriving (Show, Eq)

type PegFile = ([PPragma], ModuleName, Maybe Exports, Code, STPeg, Code)
data PPragma = LanguagePragma [String] | OtherPragma String deriving Show
type ModuleName = [String]
type Exports = String
type Code = String

type STPeg = (Maybe Type, Type, Peg)
type Peg = [Definition]
type Definition = (String, Maybe Type, Selection)
type Selection =  Either [Expression] [PlainExpression]
type Expression = Either ([(Lookahead, Check)], Exp) Exp
type PlainExpression = [(Lookahead, ReadFrom)]
type Check = Either ((Pat, String), ReadFrom, Maybe (Exp, String)) (Char, Lists)
data ReadFrom
	= FromVariable (Maybe String)
	| FromSelection Selection
	| FromL Lists ReadFrom
	deriving Show

pprCheck :: Check -> Doc
pprCheck (Left ((pt, _), rf, tst)) =
	ppr pt <> colon <> ppr rf <> maybe P.empty (brackets . ppr . fst) tst
pprCheck (Right (c, l)) = quotes (P.char c) <> ppr l

instance Ppr ReadFrom where
	ppr (FromVariable (Just v)) = text v
	ppr (FromVariable _) = P.empty
	ppr (FromL l rf) = ppr rf <> ppr l
	ppr (FromSelection sel) = parens $ ps sel
		where
		ps = hsep . intersperse (P.char '/') . either (map pe) (map ppe)
		pe (Left (ex, hs)) = (<+> braces (ppr hs)) $ hsep $
			map (uncurry ($) . (((<>) . ppr) *** pprCheck)) ex
		pe (Right ex) = P.char '<' <> ppr ex <> P.char '>'
		ppe = hsep . map (uncurry (<>) . (ppr *** ppr))


instance Ppr Lookahead where
	ppr Here = P.empty
	ppr Ahead = P.char '&'
	ppr (NAhead _) = P.char '!'

instance Ppr Lists where
	ppr List = P.char '*'
	ppr List1 = P.char '+'
	ppr Optional = P.char '?'

mkPegFile :: [PPragma] -> Maybe ([String], Maybe String) -> String -> String ->
	STPeg -> String -> PegFile
mkPegFile ps (Just md) x y z w = (ps, fst md, snd md, x ++ "\n" ++ y, z, w)
mkPegFile ps Nothing x y z w = (ps, [], Nothing, x ++ "\n" ++ y, z, w)

charList :: String -> ReadFrom
charList cs = FromSelection $ Left $ (: []) $ Right $
	InfixE Nothing (VarE $ mkName "elem") $ Just $ LitE $ StringL cs

dvCharsN :: String
dvCharsN = "char"

isVarHead :: Char -> Bool
isVarHead = (||) <$> isLower <*> (== '_')

isVarTail :: Char -> Bool
isVarTail = or <$> sequence [isUpper, isLower, isDigit, (`elem` "_'")]

isPapillonOp :: Char -> Bool
isPapillonOp = (`elem` ":&!?*+[]{}<=>()-/|")

isOpChar :: Char -> Bool
isOpChar = (`elem` ":!#$%&*+./<=>?@\\^|-~")

isSepChar :: Char -> Bool
isSepChar = (`elem` "(),;[]`{}_:")

[papillon|

monad: State (Maybe Int)

pegFile :: PegFile
	= pr:pragmas md:moduleDec pip:preImpPap _:importPapillon pp:prePeg _:pap
		_:spaces' p:peg' _:spaces' '|' ']' '\n' atp:afterPeg
			{ return $ mkPegFile pr md pip pp p atp }
	/ pr:pragmas md:moduleDec pp:prePeg _:pap _:spaces' p:peg' _:spaces'
		'|' ']' '\n' atp:afterPeg
			{ return $ mkPegFile pr md [] pp p atp }

pragmas :: [PPragma]
	= _:spaces' pr:pragma prs:pragmas	{ return $ pr : prs }
	/ _:spaces'				{ return [] }

pragma :: PPragma
	= "{-#":word 'L' 'A' 'N' 'G' 'U' 'A' 'G' 'E' _:spaces'
		s:pragmaItems _:pragmaEnd	{ return $ LanguagePragma s }
	/ "{-#":word s:pragmaStr _:pragmaEnd	{ return $ OtherPragma s }

pragmaStr :: String
	= !_:pragmaEnd c s:pragmaStr		{ return $ c : s }
	/					{ return "" }

pragmaItems :: [String]
	= t:typWord ",":hsw i:pragmaItems	{ return $ t : i }
	/ t:typWord				{ return [t] }

pragmaEnd :: ()
	= _:spaces' "#-}":word			{ return () }

moduleDec :: Maybe ([String], Maybe String)
	= "module":word n:moduleName "(":word s:moduleDecStr _:whr
						{ return $ Just (n, Just s) }
	/ "module":word n:moduleName "where":word
						{ return $ Just (n, Nothing) }
	/					{ return Nothing }

moduleName :: ModuleName
	= t:typ '.' n:moduleName		{ return $ t : n }
	/ t:typWord				{ return [t] }

moduleDecStr :: String
	= !_:whr c s:moduleDecStr		{ return $ c : s }
	/					{ return "" }

whr :: () = _:spaces' ")":word "where":word	{ return () }

preImpPap :: String
	= !_:importPapillon !_:pap c pip:preImpPap
						{ return $ c : pip }
	/					{ return "" }

prePeg :: String
	= !_:pap c pp:prePeg			{ return $ c : pp }
	/					{ return "" }

afterPeg :: String
	= c atp:afterPeg			{ return $ c : atp }
	/					{ return "" }

importPapillon :: ()
	= "import":varWord "Text":typ '.' "Papillon":typ !'.'
						{ return () }

pap :: () = '\n' "[":word "papillon":word "|":word '\n'
						{ return () }

peg :: STPeg = _:spaces _:spaces' p:peg'	{ return p }

peg' :: STPeg
	= mt:monadType? s:sourceType p:peg_	{ return (mt, ConT $
							mkName s, p) }
	/ mt:monadType? p:peg_			{ return (mt, ConT $
							mkName "String", p) }

monadType :: Type
	= (!ListPos (CharPos (_, x))):position[put (Just x) >> return True]
		"monad":varWord ":":word t:hsTypeArr _:semi	{ return t }

sourceType :: String
	= (!ListPos (CharPos (_, x))):position[put (Just x) >> return True]
		"source":varWord ":":word v:typWord _:semi	{ return v }

peg_ :: Peg
	= d:definition p:peg_			{ return $ d : p }
	/ 					{ return [] }

definition :: Definition
	= (!ListPos (CharPos (_, x))):position[put (Just x) >> return True]
		v:varWord "::":word t:hsTypeArr "=":word sel:selection _:semi
		{ return (v, Just t, sel) }
	/ (!ListPos (CharPos (_, x))):position[put (Just x) >> return True]
		v:varWord "=":word sel:plainSelection _:semi
		{ return (v, Nothing, Right sel) }

selection = normalSelection / plainSelection

normalSelection :: [Expression]
	= ex:expressionHs "/":word sel:normalSelection
						{ return $ ex : sel }
	/ ex:expressionHs			{ return [ex] }

plainSelection :: [PlainExpression]
	= ex:plainExpressionHs "/":word sel:plainSelection
						{ return $ ex : sel }
	/ ex:plainExpressionHs			{ return [ex] }

expressionHs :: Expression
	= e:expression "{":word h:hsExpLam "}":word
						{ return $ Left (e, h) }
	/ e:expressionHsSugar			{ return e }

expressionHsSugar :: Expression
	= "<":word h:hsExpLam ">":word		{ return $ Right h }

expressionHsSugar' :: Expression
	= "<":word h:hsExpLam' ">":word		{ return $ Right h }

plainExpressionHs :: PlainExpression
	= rfs:(rf:plainHAReadFromLs { return rf })*	{ return rfs }

plainHAReadFromLs :: (Lookahead, ReadFrom)
	= rf:plainReadFromLs			{ return (Here, rf) }
	/ '&' rf:plainReadFromLs		{ return (Ahead, rf) }
	/ '!' rf:plainReadFromLs		{ return (NAhead "", rf) }

plainReadFromLs :: ReadFrom
	= rf:readFromLs				{ return rf }
	/ rf:selectCharsLs			{ return rf }

expression :: [(Lookahead, Check)]
	= l:nameLeaf_ e:expression		{ return $ l : e }
	/					{ return [] }

nameLeaf_ :: (Lookahead, Check)
	= "!":word nl:nameLeafNoCom com:comForErr?
						{ return (NAhead $ maybe "" id com, nl) }
	/ "&":word nl:nameLeaf			{ return (Ahead, nl) }
	/ nl:nameLeaf				{ return (Here, nl) }

nameLeaf :: Check
	= cl:charLitLs				{ return cl }
	/ n:pat1 com:comForErr? ":":word (rf, p):leaf
		{ return $ Left ((n, maybe "" id com), rf, p) }
	/ n:pat1 com:comForErr?
		{ return $ Left ((n, maybe "" id com), FromVariable Nothing, Nothing) }

nameLeafNoCom :: Check
	= cl:charLitLs				{ return cl }
	/ n:pat1 com:comForErr? ":":word (rf, p):leaf
		{ return $ Left ((n, maybe "" id com), rf, p) }
	/ n:pat1{ return $ Left ((n, ""), FromVariable Nothing, Nothing) }

comForErr :: String
	= "{-#":word s:stringLit "#-}":word	{ return s }

leaf :: (ReadFrom, Maybe (Exp, String))
	= rf:readFromLs t:test			{ return (rf, Just t) }
	/ rf:readFromLs				{ return (rf, Nothing) }
	/ t:test				{ return (FromVariable Nothing,
							Just t) }

patOp :: Pat
	= p:pat o:opConName po:patOp		{ return $ UInfixP p o po }
	/ p:pat "`":hsw t:typWord "`":hsw po:patOp
						{ return $ UInfixP p (mkName t) po }
	/ p:pat					{ return p }

pat :: Pat
	= t:typWord ps:pats			{ return $ ConP (mkName t) ps }
	/ "(":hsw o:opConName ")":hsw ps:pats	{ return $ ConP o ps }
	/ p:pat1				{ return p }

pat1 :: Pat
	= t:typWord				{ return $ ConP (mkName t) [] }
	/ "_":hsw				{ return WildP }
	/ n:varWord				{ return $ VarP $ mkName n }
	/ i:integer				{ return $ LitP (IntegerL i) }
	/ "-":hsw i:integer			{ return $ LitP (IntegerL $ - i) }
	/ c:charLit 				{ return $ LitP $ CharL c }
	/ s:stringLit				{ return $ LitP $ StringL s }
	/ "(":hsw p:patList ")":hsw		{ return $ TupP p }
	/ "[":hsw p:patList "]":hsw		{ return $ ListP p }
	/ "(":hsw p:pat ")":hsw		{ return p }
	/ "!":hsw p:pat			{ return $ BangP p }

patList :: [Pat]
	= p:patOp ",":hsw ps:patList		{ return $ p : ps }
	/ p:patOp				{ return [p] }
	/					{ return [] }

opConName :: Name
	= ':' ot:opTail				{ return $ mkName $ ':' : ot }

pats :: [Pat]
	= p:pat ps:pats				{ return $ p : ps }
	/					{ return [] }

charLitLs :: Check
	= c:charLit "*":word			{ return $ Right (c, List) }
	/ c:charLit "+":word			{ return $ Right (c, List1) }
	/ c:charLit "?":word			{ return $ Right (c, Optional) }

readFromLs :: ReadFrom
	= rf:readFrom "*":word			{ return $ FromL List rf }
	/ rf:readFrom "+":word			{ return $ FromL List1 rf }
	/ rf:readFrom "?":word			{ return $ FromL Optional rf }
	/ rf:readFrom				{ return rf }

readFrom :: ReadFrom
	= v:varWord				{ return $ FromVariable $ Just v }
	/ "(":word s:selection ")":word		{ return $ FromSelection s }
--	/ '(' s:selection ')'		{ return $ FromSelection s }
	/ e:expressionHsSugar'			{ return $ FromSelection $ Left [e] }

selectCharsLs :: ReadFrom
	= rf:selectChars "*":word		{ return $ FromL List rf }
	/ rf:selectChars "+":word		{ return $ FromL List1 rf }
	/ rf:selectChars "?":word		{ return $ FromL Optional rf }
	/ rf:selectChars			{ return rf }

selectChars :: ReadFrom
	= "[":word cs:<(`notElem` "\\-")>+ "]":word	{ return $ charList cs }
	/ "[":word cb:<(`notElem` "\\-")> "-":word ce:<(`notElem` "\\-")> "]":word
						{ return $ charList [cb .. ce] }
--	/ '\'' c:<(`notElem` "\\'")> '\''	{ return $ charList [c] }
	/ c:charLit				{ return $ charList [c] }

test :: (Exp, String)
	= "[":word h:hsExpLam com:comForErr? "]":word
						{ return (h, maybe "" id com) }

hsExpLam :: Exp
	= "\\":hsw ps:pats "->":hsw e:hsExpTyp{ return $ LamE ps e }
	/ e:hsExpTyp				{ return e }

hsExpTyp :: Exp
	= eo:hsExpOp "::":hsw t:hsTypeArr	{ return $ SigE eo t }
	/ eo:hsExpOp				{ return eo }

hsExpOp :: Exp
	= l:hsExp o:hsOp r:hsExpOp		{ return $ UInfixE (l id) o r }
	/ e:hsExp				{ return $ e id }

hsOp :: Exp
	= op:hsw[return $ all isOpChar op && head op /= ':']
						{ return $ VarE $ mkName op }
	/ op:hsw[return $ all isOpChar op && op /= "::"]
						{ return $ ConE $ mkName op }
	/ "`":hsw v:varWord "`":hsw		{ return $ VarE $ mkName v }
	/ "`":hsw t:typWord "`":hsw		{ return $ ConE $ mkName t }


hsExpLam' :: Exp
	= "\\":hsw ps:pats "->":hsw e:hsExpTyp'
						{ return $ LamE ps e }
	/ e:hsExpTyp'				{ return e }

hsExpTyp' :: Exp
	= eo:hsExpOp' "::":hsw t:hsTypeArr	{ return $ SigE eo t }
	/ eo:hsExpOp'				{ return eo }

hsExpOp' :: Exp
	= l:hsExp o:hsOp' r:hsExpOp'		{ return $ UInfixE (l id) o r }
	/ e:hsExp				{ return $ e id }

hsOp' :: Exp
	= op:hsw[return $ all isOpChar op && head op /= ':' && head op /= '>']
						{ return $ VarE $ mkName op }
	/ op:hsw[return $ all isOpChar op && op /= "::" && head op /= '>']
						{ return $ ConE $ mkName op }
	/ "`":hsw v:var "`":hsw		{ return $ VarE $ mkName v }
	/ "`":hsw t:typ "`":hsw		{ return $ ConE $ mkName t }

opTail :: String
	= c:<(`elem` ":+*/-!|&.^=<>$")> s:opTail{ return $ c : s }
	/					{ return "" }

hsExp :: (Exp -> Exp) -> Exp
	= e:hsExp1 h:hsExp			{return (\f->h (f e `AppE`))}
	/ e:hsExp1				{return (\f->f e)}

hsExp1 :: Exp
	= "(":hsw l:hsExpOp? o:hsOp r:hsExpOp? ")":hsw
						{ return $ InfixE l o r }
	/ "(":hsw et:hsExpTpl ")":hsw		{ return $ TupE et }
	/ "[":hsw et:hsExpTpl "]":hsw		{ return $ ListE et }
	/ v:varWord				{ return $ VarE $ mkName v }
	/ t:typWord				{ return $ ConE $ mkName t }
	/ i:integer				{ return $ LitE $ integerL i }
	/ c:charLit				{ return $ LitE $ charL c }
	/ s:stringLit				{ return $ LitE $ stringL s }
	/ "-":hsw e:hsExp1			{ return $ AppE (VarE $ mkName "negate") e }

hsExpTpl :: [Exp]
	= e:hsExpLam ",":hsw et:hsExpTpl
						{ return $ e : et }
	/ e:hsExpLam				{ return [e] }
	/					{ return [] }

hsTypeArr :: Type
	= l:hsType "->":hsw r:hsTypeArr	{ return $ AppT (AppT ArrowT $ l id) r }
	/ t:hsType				{ return $ t id }

hsType :: (Type -> Type) -> Type
	= t:hsType1 ts:hsType			{ return $(\f -> ts (f t `AppT`)) }
	/ t:hsType1				{ return ($ t) }

hsType1 :: Type
	= "[":hsw "]":hsw			{ return ListT }
	/ "[":hsw t:hsTypeArr "]":hsw		{ return $ ListT `AppT` t }
	/ "(":hsw tt:hsTypeTpl ")":hsw		{ return $ foldl AppT
							(TupleT $ length tt) tt }
	/ t:typWord				{ return $ ConT $ mkName t }
	/ "(":hsw "->":hsw ")":hsw		{ return ArrowT }

hsTypeTpl :: [Type]
	= t:hsTypeArr ",":hsw tt:hsTypeTpl	{ return $ t : tt }
	/ t:hsTypeArr				{ return [t] }
	/					{ return [] }

typWord :: String = t:typ _:spaces		{ return t }
varWord :: String = v:var _:spaces		{ return v }

typ :: String = u:<isUpper> t:<isVarTail>*	{ return $ u : t }
var :: String = l:<isVarHead> t:<isVarTail>*	{ return $ l : t }

integer :: Integer = ds:hsw[return $ all isDigit ds]
						{ return $ read $ ds }

word :: String
	= w:<isAlphaNum>+ _:spaces		{ return w }
	/ ':' ':' _:spaces			{ return "::" }
	/ '{' '-' '#' _:spaces			{ return "{-#" }
	/ '#' '-' '}' _:spaces			{ return "#-}" }
	/ w:<isPapillonOp> _:spaces		{ return [w] }

hsw :: String
	= w:<isAlphaNum>+ _:spaces		{ return w }
	/ '|' ']' _:spaces			{ return "|]" }
	/ w:<isOpChar>+ _:spaces		{ return w }
	/ w:<isSepChar> _:spaces		{ return [w] }

charLit :: Char
	= '\'' c:<(`notElem` "\\'")> '\'' _:spaces	{ return c }
	/ '\'' '\\' c:escapeC '\'' _:spaces	{ return c }

stringLit :: String
	= '"' s:stringLit_ '"' _:spaces		{ return s }

stringLit_ :: String
	= c:<(`notElem` "\"\\")> s:stringLit_	{ return $ c : s }
	/ '\\' c:escapeC s:stringLit_		{ return $ c : s }
	/					{ return "" }

escapeC :: Char
	= '"'					{ return '"' }
	/ '\''					{ return '\'' }
	/ '\\'					{ return '\\' }
	/ 'n'					{ return '\n' }
	/ 't'					{ return '\t' }

spaces' :: () = _:<isSpace>*			{ return () }

spaces :: ()
	= _:space _:spaces			{ return () }
	/ 					{ return () }

space :: ()
	= s:[return $ s `elem` " \t"]		{ return () }
	/ _:notSemiColon			{ return () }
	/ _:lineComment				{ return () }
	/ _:comment				{ return () }

lineComment :: () = '-' '-' _:notNLString &'\n'	{ return () }

notNLString :: String
	= !'\n' c s:notNLString			{ return $ c : s }
	/					{ return "" }

comment :: ()
	= '{' '-' !'#' _:comments _:comEnd	{ return () }

comments :: ()
	= _:notComStr _:comment _:comments	{ return () }
	/ _:notComStr				{ return () }

notComStr :: ()
	= !_:comment !_:comEnd _ _:notComStr	{ return () }
	/					{ return () }

comEnd :: ()
	= '-' '}'				{ return () }

semi :: () = _:semiColon _:spaces		{ put Nothing }

semiColon :: ()
	= ';' _:newLine?			{ return () }
	/ _:newLine _:headSpace*
		(!ListPos (CharPos (_, h))):position[get>>=
			(\b -> return $ maybe False (>=h) b)]
		';' _:newLine?
						{ return () }
	/ _:newLine _:headSpace*
		(!ListPos (CharPos (_, h))):position[get>>=
			(\b -> return $ maybe False (>=h) b)]
		!_:lineComment !_:comment
						{ return () }
	/ !_:[return True]			{ return () }

notSemiColon :: ()
	= _:newLine _:headSpace
		(!ListPos (CharPos (_, h))):position[get>>=
			(\b -> return $ maybe True (< h) b)]
						{ return () }
	/ _:newLine _:lineComment		{ return () }
	/ _:newLine _:comment			{ return () }

newLine :: () = '\n'+				{ return () }

headSpace :: () = '\t' { return () } / ' ' { return () }

|]
