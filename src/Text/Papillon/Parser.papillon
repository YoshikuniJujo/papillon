{-# LANGUAGE FlexibleContexts, TemplateHaskell, UndecidableInstances #-}

module Text.Papillon.Parser (
	Lookahead(..),
	Lists(..),

	Peg,
	Definition,
	Selection,
	Expression,
	PlainExpression,
	Check,
	ReadFrom(..),

	getType,
	pprCheck,
	readings,

	parse,
	Source(..),
	SourceList(..),
	Derivs(pegFile, peg, char),
	ParseError(..),
	mkParseError,
	pePositionS,
	Pos(..),
	ListPos(..),

	PPragma(..),
	ModuleName,
	Exports,
	Code,

	runError,

	dvCharsN
) where

import Text.Papillon.SyntaxTree
import Language.Haskell.TH {- (
	Name, TypeQ, PatQ, ExpQ, mkName,
	conT, tupleT, listT, appT, arrowT,
	wildP, litP, varP, conP, tupP, listP, uInfixP,
	litE, varE, conE, tupE, listE, sigE, appE, infixE, uInfixE, lamE,
	integerL, charL, stringL) -}
import Data.Char (isSpace, isDigit, isUpper, isLower)

[papillon|

pegFile :: PegFile
	= pr:pragmas md:moduleDec pip:preImpPap _:importPapillon pp:prePeg _:pap
		p:peg _:spaces '|' ']' '\n' atp:afterPeg
			{ mkPegFile pr md pip pp p atp }
	/ pr:pragmas md:moduleDec pp:prePeg _:pap p:peg _:spaces
		'|' ']' '\n' atp:afterPeg
			{ mkPegFile pr md [] pp p atp }
;
pragmas :: [PPragma]
	= _:spaces pr:pragma prs:pragmas	{ pr : prs }
	/ _:spaces				{ [] }
;
pragma :: PPragma
	= '{' '-' '#' _:spaces 'L' 'A' 'N' 'G' 'U' 'A' 'G' 'E' _:spaces
		s:pragmaItems _:pragmaEnd _:spaces	{ LanguagePragma s }
	/ '{' '-' '#' _:spaces s:pragmaStr _:pragmaEnd	{ OtherPragma s }
;
pragmaStr :: String
	= !_:pragmaEnd c s:pragmaStr		{ c : s }
	/					{ "" }
;
pragmaItems :: [String]
	= t:typToken ',' _:spaces i:pragmaItems	{ t : i }
	/ t:typToken				{ [t] }
;
pragmaEnd :: ()
	= _:spaces '#' '-' '}'			{ () }
;
moduleDec :: Maybe ([String], Maybe String)
	= 'm' 'o' 'd' 'u' 'l' 'e' _:spaces
		n:moduleName _:spaces
		'(' _:spaces s:moduleDecStr _:whr
						{ Just (n, Just s) }
	/ 'm' 'o' 'd' 'u' 'l' 'e' _:spaces
		n:moduleName _:spaces 'w' 'h' 'e' 'r' 'e' _:spaces
						{ Just (n, Nothing) }
	/					{ Nothing }
;
moduleName :: ModuleName
	= t:typ '.' n:moduleName		{ t : n }
	/ t:typ					{ [t] }
;
moduleDecStr :: String
	= !_:whr c s:moduleDecStr		{ c : s }
	/					{ "" }
;
whr :: ()
	= _:spaces ')' _:spaces 'w' 'h' 'e' 'r' 'e'
						{ () }
;
preImpPap :: String
	= !_:importPapillon !_:pap c pip:preImpPap
						{ c : pip }
	/					{ "" }
;
prePeg :: String
	= !_:pap c pp:prePeg			{ c : pp }
	/					{ "" }
;
afterPeg :: String
	= c atp:afterPeg			{ c : atp }
	/					{ "" }
;
importPapillon :: ()
	= "import":varToken "Text":typToken '.' _:spaces "Papillon":typToken
		!'.'				{ () }
;
varToken :: String
	= v:variable _:spaces			{ v }
;
typToken :: String
	= t:typ _:spaces			{ t }
;
pap :: ()
	= '\n' '[' 'p' 'a' 'p' 'i' 'l' 'l' 'o' 'n' '|' '\n'	{ () }
;
peg :: STPeg
	= mt:monadType? _:spaces s:sourceType p:peg_
		{ (mt, ConT $ mkName s, p) }
	/ mt:monadType? p:peg_				
		{ (mt, ConT $ mkName "String", p) }
;
monadType :: Type
	= _:spaces "monad":varToken ':' _:spaces t:hsTypeArr	{ t }
;
sourceType :: String
	= "source":varToken ':' _:spaces v:typToken
						{ v }
;
peg_ :: Peg
	= _:spaces d:definition p:peg_		{ d : p }
	/ 					{ [] }
;
definition :: Definition
	= v:variable _:spaces ':' ':'
		_:spaces t:hsTypeArr _:spaces '='
		_:spaces sel:selection _:spaces ';'
						{ (v, Just t, sel) }
	/ v:variable _:spaces '<' '-' _:spaces
		sel:plainSelection _:spaces ';'	{ (v, Nothing, Right sel) }
	/ v:variable _:spaces '=' _:spaces
		sel:plainSelection _:spaces ';'	{ (v, Nothing, Right sel) }
;
selection = normalSelection / plainSelection
;
normalSelection :: [Expression]
	= ex:expressionHs _:spaces '/' _:spaces sel:normalSelection
						{ ex : sel }
	/ ex:expressionHs			{ [ex] }
;
plainSelection :: [PlainExpression]
	= ex:plainExpressionHs _:spaces '/' _:spaces sel:plainSelection
						{ ex : sel }
	/ ex:plainExpressionHs			{ [ex] }
;
expressionHs :: Expression
	= e:expression _:spaces '{' _:spaces h:hsExpLam _:spaces '}'
						{ Left (e, h) }
	/ e:expressionHsSugar			{ e }
;
expressionHsSugar :: Expression
	= '<' _:spaces h:hsExpLam _:spaces '>'	{ Right h }
;
expressionHsSugar' :: Expression
	= '<' _:spaces h:hsExpLam' _:spaces '>'	{ Right h }
;
plainExpressionHs :: PlainExpression
	= rfs:(rf:plainHAReadFromLs _:spaces { rf })*	{ rfs }
;
plainHAReadFromLs :: (Lookahead, ReadFrom)
	= rf:plainReadFromLs			{ (Here, rf) }
	/ '&' rf:plainReadFromLs		{ (Ahead, rf) }
	/ '!' rf:plainReadFromLs		{ (NAhead "", rf) }
;
plainReadFromLs :: ReadFrom
	= rf:readFromLs				{ rf }
	/ rf:selectCharsLs			{ rf }
;
expression :: [(Lookahead, Check)]
	= l:nameLeaf_ _:spaces e:expression	{ l : e }
	/ 					{ [] }
;
nameLeaf_ :: (Lookahead, Check)
	= '!' nl:nameLeafNoCom _:spaces com:comForErr?
						{ (NAhead $ maybe "" id com, nl) }
	/ '&' nl:nameLeaf			{ (Ahead, nl) }
	/ nl:nameLeaf				{ (Here, nl) }
;
nameLeaf :: Check
	= n:pat1 _:spaces com:comForErr? ':' (rf, p):leaf
		{ ((n, maybe "" id com), rf, p) }
	/ n:pat1 _:spaces com:comForErr?
		{ ((n, maybe "" id com), FromVariable Nothing, Nothing) }
;
nameLeafNoCom :: Check
	= n:pat1 _:spaces com:comForErr? ':' (rf, p):leaf
		{ ((n, maybe "" id com), rf, p) }
	/ n:pat1 _:spaces
		{ ((n, ""), FromVariable Nothing, Nothing) }
;
comForErr :: String
	= '{' '-' '#' _:spaces '"' s:stringLit '"' _:spaces '#' '-' '}' _:spaces
						{ s }
;
leaf :: (ReadFrom, Maybe (Exp, String))
	= rf:readFromLs t:test			{ (rf, Just t) }
	/ rf:readFromLs				{ (rf, Nothing) }
	/ t:test			{ (FromVariable Nothing, Just t) }
;
patOp :: Pat
	= p:pat o:opConName po:patOp		{ UInfixP p o po }
	/ p:pat _:spaces '`' t:typ '`' _:spaces po:patOp
						{ UInfixP p (mkName t) po }
	/ p:pat					{ p }
;
pat :: Pat
	= t:typ _:spaces ps:pats		{ ConP (mkName t) ps }
	/ '(' o:opConName ')'_:spaces ps:pats	{ ConP o ps }
	/ p:pat1				{ p }
;
pat1 :: Pat
	= t:typ					{ ConP (mkName t) [] }
	/ "_":variable				{ WildP }
	/ n:variable				{ VarP $ mkName n }
	/ i:integer				{ LitP (IntegerL i) }
	/ '-' _:spaces i:integer		{ LitP (IntegerL $ - i) }
	/ '\'' c:charLit '\''			{ LitP $ CharL c }
	/ '"' s:stringLit '"'			{ LitP $ StringL s }
	/ '(' p:patList ')'			{ TupP p }
	/ '[' p:patList ']'			{ ListP p }
;
patList :: [Pat]
	= p:patOp _:spaces ',' _:spaces ps:patList
						{ p : ps }
	/ p:patOp				{ [p] }
	/					{ [] }
;
opConName :: Name
	= ':' ot:opTail				{ mkName $ ':' : ot }
;
charLit :: Char
	= c:[c `notElem` "\\'"]			{ c }
	/ '\\' c:escapeC			{ c }
;
stringLit :: String
	= c:[c `notElem` "\"\\"] s:stringLit	{ c : s }
	/ '\\' c:escapeC s:stringLit		{ c : s }
	/					{ "" }
;
escapeC :: Char
	= '"'					{ '"' }
	/ '\''					{ '\'' }
	/ '\\'					{ '\\' }
	/ 'n'					{ '\n' }
	/ 't'					{ '\t' }
;
pats :: [Pat]
	= p:pat _:spaces ps:pats		{ p : ps }
	/					{ [] }
;
readFromLs :: ReadFrom
	= rf:readFrom '*'			{ FromL List rf }
	/ rf:readFrom '+'			{ FromL List1 rf }
	/ rf:readFrom '?'			{ FromL Optional rf }
	/ rf:readFrom				{ rf }
;
readFrom :: ReadFrom
	= v:variable				{ FromVariable $ Just v }
	/ '(' s:selection ')'			{ FromSelection s }
	/ e:expressionHsSugar'			{ FromSelection $ Left [e] }
;
selectCharsLs :: ReadFrom
	= rf:selectChars '*'			{ FromL List rf }
	/ rf:selectChars '+'			{ FromL List1 rf }
	/ rf:selectChars '?'			{ FromL Optional rf }
	/ rf:selectChars			{ rf }
;
selectChars :: ReadFrom
	= '[' cs:<(`notElem` "\\-")>+ ']'	{ charList cs }
	/ '[' cb:[cb `notElem` "\\-"] '-'
		ce:[ce `notElem` "\\-"] ']'	{ charList [cb .. ce] }
	/ '\'' c:[c `notElem` "\\'"] '\''	{ charList [c] }
;
test :: (Exp, String)
	= '[' h:hsExpLam _:spaces com:comForErr? ']'
						{ (h, maybe "" id com) }
;
hsExpLam :: Exp
	= '\\' _:spaces ps:pats _:spaces '-' '>' _:spaces e:hsExpTyp
						{ LamE ps e }
	/ e:hsExpTyp				{ e }
;
hsExpTyp :: Exp
	= eo:hsExpOp ':' ':' _:spaces t:hsTypeArr
						{ SigE eo t }
	/ eo:hsExpOp				{ eo }
;
hsExpOp :: Exp
	= l:hsExp _:spaces o:hsOp _:spaces r:hsExpOp
						{ UInfixE (l id) o r }
	/ e:hsExp				{ e id }
;
hsOp :: Exp
	= c:[c `elem` "+*/-!|&.^=<>$"] o:opTail { VarE $ mkName $ c : o }
	/ ':' !':' o:opTail			{ ConE $ mkName $ ':' : o }
	/ '`' v:variable '`'			{ VarE $ mkName v }
	/ '`' t:typ '`'				{ ConE $ mkName t }
;

hsExpLam' :: Exp
	= '\\' _:spaces ps:pats _:spaces '-' '>' _:spaces e:hsExpTyp'
						{ LamE ps e }
	/ e:hsExpTyp'				{ e }
;
hsExpTyp' :: Exp
	= eo:hsExpOp' ':' ':' _:spaces t:hsTypeArr
						{ SigE eo t }
	/ eo:hsExpOp'				{ eo }
;
hsExpOp' :: Exp
	= l:hsExp _:spaces o:hsOp' _:spaces r:hsExpOp'
						{ UInfixE (l id) o r }
	/ e:hsExp				{ e id }
;
hsOp' :: Exp
	= c:[c `elem` "+*/-!|&.^=<$"] o:opTail { VarE $ mkName $ c : o }
	/ ':' !':' o:opTail			{ ConE $ mkName $ ':' : o }
	/ '`' v:variable '`'			{ VarE $ mkName v }
	/ '`' t:typ '`'				{ ConE $ mkName t }
;

opTail :: String
	= c:[c `elem` ":+*/-!|&.^=<>$"] s:opTail{ c : s }
	/					{ "" }
;
hsExp :: (Exp -> Exp) -> Exp
	= e:hsExp1 _:spaces h:hsExp		{ \f -> h (f e `AppE`) }
	/ e:hsExp1				{ \f -> f e }
;
hsExp1 :: Exp
	= '(' l:(e:hsExpTyp {e})? _:spaces o:hsOp _:spaces r:(e:hsExpTyp {e})? ')'
						{ InfixE l o r }
	/ '(' et:hsExpTpl ')'			{ TupE et }
	/ '[' et:hsExpTpl ']'			{ ListE et }
	/ v:variable				{ VarE $ mkName v }
	/ t:typ					{ ConE $ mkName t }
	/ i:integer _:spaces			{ LitE $ integerL i }
	/ '\'' c:charLit '\''			{ LitE $ charL c }
	/ '"' s:stringLit '"'			{ LitE $ stringL s }
	/ '-' _:spaces e:hsExp1			{ AppE (VarE $ mkName "negate") e }
;
hsExpTpl :: [Exp]
	= e:hsExpLam _:spaces ',' _:spaces et:hsExpTpl
						{ e : et }
	/ e:hsExpLam				{ [e] }
	/					{ [] }
;
hsTypeArr :: Type
	= l:hsType '-' '>' _:spaces r:hsTypeArr
						{ AppT (AppT ArrowT $ l id) r }
	/ t:hsType				{ t id }
;
hsType :: (Type -> Type) -> Type
	= t:hsType1 ts:hsType			{ \f -> ts (f t `AppT`) }
	/ t:hsType1				{ ($ t) }
;
hsType1 :: Type
	= '[' ']' _:spaces			{ ListT }
	/ '[' t:hsTypeArr ']' _:spaces		{ ListT `AppT` t }
	/ '(' _:spaces tt:hsTypeTpl ')' _:spaces
					{ foldl AppT (TupleT $ length tt) tt }
	/ t:typToken				{ ConT $ mkName t }
	/ '(' '-' '>' ')' _:spaces		{ ArrowT }
;
hsTypeTpl :: [Type]
	= t:hsTypeArr ',' _:spaces tt:hsTypeTpl
						{ t : tt }
	/ t:hsTypeArr				{ [t] }
	/					{ [] }
;
typ :: String
	= u:upper t:tvtail			{ u : t }
;
variable :: String
	= l:lower t:tvtail			{ l : t }
;
tvtail :: String
	= a:alpha t:tvtail			{ a : t }
	/ 					{ "" }
;
integer :: Integer
	= dh:digit ds:(d:digit { d })*		{ read $ dh : ds }
;
alpha :: Char
	= u:upper				{ u }
	/ l:lower				{ l }
	/ d:digit				{ d }
	/ '\''					{ '\'' }
;
upper :: Char
	= u:[isUpper u]				{ u }
;
lower :: Char
	= l:[isLower l || l == '_' ]		{ l }
;
digit :: Char
	= d:[isDigit d]				{ d }
;
spaces :: ()
	= _:space _:spaces			{ () }
	/ 					{ () }
;
space :: ()
	= s:[isSpace s]				{ () }
	/ '-' '-' _:notNLString _:newLine	{ () }
	/ _:comment				{ () }
;
notNLString :: String
	= !_:newLine c s:notNLString		{ c : s }
	/					{ "" }
;
newLine :: ()
	= '\n'					{ () }
;
comment :: ()
	= '{' '-' !'#' _:comments _:comEnd	{ () }
;
comments :: ()
	= _:notComStr _:comment _:comments	{ () }
	/ _:notComStr				{ () }
;
notComStr :: ()
	= !_:comment !_:comEnd _ _:notComStr	{ () }
	/					{ () }
;
comEnd :: ()
	= '-' '}'				{ () }
;

|]
