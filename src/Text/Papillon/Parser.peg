{-# LANGUAGE FlexibleContexts, TemplateHaskell, UndecidableInstances #-}

module Text.Papillon.Parser (
	Peg,
	Definition,
	Selection,
	ExpressionHs,
	NameLeaf(..),
	NameLeaf_(..),
	parse,
	dv_peg,
	dv_pegFile,
	initialPos,
) where

import Data.Char
import Language.Haskell.TH

type MaybeString = Maybe String

type Nil = ()
-- type Leaf = Either String ExR
type Leaf = (Maybe String, ExR)
data NameLeaf
	= NameLeaf PatQ Leaf
	| NameLeafList PatQ Selection
data NameLeaf_ = NotAfter NameLeaf | Here NameLeaf
notAfter, here :: NameLeaf -> NameLeaf_
notAfter = NotAfter
here = Here
type Expression = [NameLeaf_]
type ExpressionHs = (Expression, ExR)
type Selection = [ExpressionHs]
type Typ = Name
type Definition = (String, Typ, Selection)
type Peg = [Definition]
type TTPeg = (TypeQ, TypeQ, Peg)

type Ex = (ExpQ -> ExpQ) -> ExpQ
type ExR = ExpQ

ctLeaf :: Leaf
-- ctLeaf = Right $ conE (mkName "True") -- varE (mkName "const") `appE` conE (mkName "True")
ctLeaf = (Nothing, conE $ mkName "True")

ruleLeaf :: String -> ExpQ -> Leaf
boolLeaf :: ExpQ -> Leaf
ruleLeaf r t = (Just r, t) -- Left
boolLeaf p = (Nothing, p) -- Right

true :: ExpQ
true = conE $ mkName "True"

just :: a -> Maybe a
just = Just
nothing :: Maybe a
nothing = Nothing

nil :: Nil
nil = ()

cons :: a -> [a] -> [a]
cons = (:)

type PatQs = [PatQ]

mkNameLeaf :: PatQ -> Leaf -> NameLeaf
mkNameLeaf = NameLeaf

mkNameLeafList :: PatQ -> Selection -> NameLeaf
mkNameLeafList = NameLeafList

strToPatQ :: String -> PatQ
strToPatQ = varP . mkName

conToPatQ :: String -> [PatQ] -> PatQ
conToPatQ t ps = conP (mkName t) ps

mkExpressionHs :: a -> Ex -> (a, ExR)
mkExpressionHs x y = (x, getEx y)

mkDef :: a -> String -> c -> (a, Name, c)
mkDef x y z = (x, mkName y, z)

toExp :: String -> Ex
-- toExp v = \f -> f `appE` varE (mkName v)
toExp v = \f -> f $ varE (mkName v)

apply :: String -> Ex -> Ex
apply f x = \g -> x (toExp f g `appE`)

getEx :: Ex -> ExR
getEx ex = ex id -- (varE $ mkName "id")

emp :: [a]
emp = []

type PegFile = (String, String, TTPeg, String)
mkPegFile :: Maybe String -> Maybe String -> String -> String -> TTPeg -> String
	-> PegFile
mkPegFile (Just p) (Just md) x y z w =
	("{-#" ++ p ++ addPragmas ++ "module " ++ md ++ " where\n" ++
	addModules,
	x ++ "\n" ++ y, z, w)
mkPegFile Nothing (Just md) x y z w =
	(x ++ "\n" ++ "module " ++ md ++ " where\n" ++
	addModules,
	x ++ "\n" ++ y, z, w)
mkPegFile (Just p) Nothing x y z w = (
	"{-#" ++ p ++ addPragmas ++
	addModules,
	x ++ "\n" ++ y
	, z, w)
mkPegFile Nothing Nothing x y z w = (addModules, x ++ "\n" ++ y, z, w)

addPragmas, addModules :: String
addPragmas =
	", FlexibleContexts, PackageImports, TypeFamilies, RankNTypes, " ++
	"FlexibleInstances #-}\n"
addModules =
	"import \"monads-tf\" Control.Monad.State\n" ++
	"import \"monads-tf\" Control.Monad.Error\n" ++
	"import Control.Monad.Trans.Error (Error (..))\n"

charP :: Char -> PatQ
charP = litP . charL
stringP :: String -> PatQ
stringP = litP . stringL

isAlphaNumOt, elemNTs :: Char -> Bool
isAlphaNumOt c = isAlphaNum c || c `elem` "{-#.\":}|[]!;=/ *()"
elemNTs = (`elem` "nt\\'")

isKome, isOpen, isClose :: Char -> Bool
isKome = (== '*')
isOpen = (== '(')
isClose = (== ')')

getNTs :: Char -> Char
getNTs 'n' = '\n'
getNTs 't' = '\t'
getNTs '\\' = '\\'
getNTs '\'' = '\''
getNTs o = o
isLowerU :: Char -> Bool
isLowerU c = isLower c || c == '_'

tString :: String
tString = "String"
mkTTPeg :: String -> Peg -> TTPeg
mkTTPeg s p =
	(conT $ mkName s, conT (mkName "Token") `appT` conT (mkName s), p)

[papillon|

pegFile :: PegFile
	= pr:pragma md:moduleDec pip:preImpPap _:importPapillon pp:prePeg _:pap
		p:peg _:spaces '|' ']' '\n' atp:afterPeg
			{ mkPegFile pr md pip pp p atp }
	/ pr:pragma md:moduleDec pp:prePeg _:pap p:peg _:spaces
		'|' ']' '\n' atp:afterPeg
			{ mkPegFile pr md emp pp p atp }
;
pragma :: MaybeString
	= _:spaces '{' '-' '#' s:pragmaStr _:pragmaEnd _:spaces { just s }
	/ _:spaces						{ nothing }
;
pragmaStr :: String
	= !_:pragmaEnd c s:pragmaStr		{ cons c s }
	/					{ emp }
;
pragmaEnd :: Nil
	= '#' '-' '}'				{ nil }
;
moduleDec :: MaybeString
	= 'm' 'o' 'd' 'u' 'l' 'e' s:moduleDecStr _:whr	{ just s }
	/						{ nothing }
;
moduleDecStr :: String
	= !_:whr c s:moduleDecStr			{ cons c s }
	/						{ emp }
;
whr :: Nil
	= 'w' 'h' 'e' 'r' 'e'				{ nil }
;
preImpPap :: String
	= !_:importPapillon !_:pap c pip:preImpPap	{ cons c pip }
	/					{ emp }
;
prePeg :: String
	= !_:pap c pp:prePeg	{ cons c pp }
	/					{ emp }
;
afterPeg :: String
	= c atp:afterPeg		{ cons c atp }
	/					{ emp }
;
importPapillon :: Nil
	= "import":varToken "Text":typToken '.' _:spaces "Papillon":typToken
		{ nil }
;
varToken :: String
	= v:variable _:spaces			{ v }
;
typToken :: String
	= t:typ _:spaces			{ t }
;
pap :: Nil
	= '\n' '[' 'p' 'a' 'p' 'i' 'l' 'l' 'o' 'n' '|' '\n'	{ nil }
;
peg :: TTPeg
	= _:spaces s:sourceType p:peg_		{ mkTTPeg s p }
	/ p:peg_				{ mkTTPeg tString p }
;
sourceType :: String
	= "source":varToken ':' _:spaces v:typToken	{ v }
;
peg_ :: Peg
	= _:spaces d:definition p:peg_	{ cons d p }
	/ 	{ emp }
;
definition :: Definition
	= v:variable _:spaces ':' ':'
		_:spaces t:typ _:spaces '='
		_:spaces sel:selection _:spaces ';'	{ mkDef v t sel }
;
{-
typeExp :: TypeQ
	= typToken					{ 
;
-}
selection :: Selection
	= ex:expressionHs _:spaces '/' _:spaces sel:selection	{ cons ex sel }
	/ ex:expressionHs	{ cons ex emp }
;
expressionHs :: ExpressionHs
	= e:expression _:spaces '{' _:spaces h:hsExp _:spaces '}'
		{ mkExpressionHs e h }
;
expression :: Expression
	= l:nameLeaf_ _:spaces e:expression	{ cons l e }
	/ 	{ emp }
;
nameLeaf_ :: NameLeaf_
	= '!' nl:nameLeaf			{ notAfter nl }
	/ nl:nameLeaf				{ here nl }
;
nameLeaf :: NameLeaf
	= n:pat1 ':' o:[isOpen o] ex:selection c:[isClose c] k:[isKome k] _:spaces
		{ mkNameLeafList n ex }
	/ o:[isOpen o] nl:nameLeaf c:[isClose c]	{ nl }
	/ n:pat1 ':' l:leaf		{ mkNameLeaf n l }
	/ n:pat1					{ mkNameLeaf n ctLeaf }
--	/ ':' l:leaf_			{ mkNameLeaf wildP l }
;
pat :: PatQ
	= t:typ _:spaces ps:pats		{ conToPatQ t ps }
	/ p:pat1				{ p }
;
pat1 :: PatQ
	= "_":variable				{ wildP }
	/ n:variable				{ strToPatQ n }
	/ '\'' c:charLit '\''			{ charP c }
	/ '"' s:stringLit '"'			{ stringP s }
	/ t:typ					{ conToPatQ t emp }
	/ '(' p:pat ')'				{ p }
;
charLit :: Char
	= c:[isAlphaNumOt c]			{ c }
	/ '\\' c:[elemNTs c]			{ getNTs c }
;
stringLit :: String
	= !_:dq c s:stringLit			{ cons c s }
	/					{ emp }
;
dq :: Nil
	= '"'					{ nil }
;
pats :: PatQs
	= p:pat ps:pats				{ cons p ps }
	/					{ emp }
;
leaf :: Leaf
	= t:test				{ boolLeaf t }
	/ v:variable t:test			{ ruleLeaf v t }
	/ v:variable				{ ruleLeaf v true }
;
test :: ExR
	= '[' h:hsExp ']'		{ getEx h }
;
hsExp :: Ex
	= v:variable _:spaces h:hsExp	{ apply v h }
	/ v:variable	{ toExp v }
;
typ :: String
	= u:upper t:tvtail	{ cons u t }
;
variable :: String
	= l:lower t:tvtail	{ cons l t }
;
tvtail :: String
	= a:alpha t:tvtail	{ cons a t }
	/ 	{ emp }
;
alpha :: Char
	= u:upper	{ u }
	/ l:lower	{ l }
	/ d:digit	{ d }
;
upper :: Char
	= u:[isUpper u]		{ u }
;
lower :: Char
	= l:[isLowerU l]	{ l }
;
digit :: Char
	= d:[isDigit d]		{ d }
;
spaces :: Nil
	= _:space _:spaces	{ nil }
	/ 	{ nil }
;
space :: Nil
	= s:[isSpace s]			{ nil }
	/ '-' '-' _:notNLString _:nl	{ nil }
	/ _:comment			{ nil }
;
notNLString :: String
	= !_:nl c s:notNLString	{ cons c s }
	/			{ emp }
;
nl :: Nil
	= '\n'			{ nil }
;
comment :: Nil
	= '{' '-' !'#' _:comments _:comEnd	{ nil }
;
comments :: Nil
	= _:notComStr _:comment _:comments	{ nil }
	/ _:notComStr				{ nil }
;
notComStr :: Nil
	= !_:comment !_:comEnd _ _:notComStr	{ nil }
	/				{ nil }
;
comEnd :: Nil
	= '-' '}'			{ nil }
;

|]
