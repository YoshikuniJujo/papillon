{-# LANGUAGE FlexibleContexts, TemplateHaskell, UndecidableInstances #-}

module Text.Papillon.Parser (
	Peg,
	Definition(..),
	Selection(..),
	getSelectionType,
	ExpressionHs(..),
	NameLeaf(..),
	NameLeaf_(..),
	ReadFrom(..),
	parse,
	showNameLeaf,
	nameFromRF,
	ParseError(..),
	mkParseError,
	Derivs(peg, pegFile, char),
	Pos(..),
	ListPos(..),
	pePositionS,
	Source(..),
	SourceList(..),

	PPragma(..),
	ModuleName,
	ExportList,
	Code
) where

import Data.Char
import Language.Haskell.TH
import Text.Papillon.SyntaxTree

[papillon|

pegFile :: PegFile
	= pr:pragmas md:moduleDec pip:preImpPap _:importPapillon pp:prePeg _:pap
		p:peg _:spaces '|' ']' '\n' atp:afterPeg
			{ mkPegFile pr md pip pp p atp }
	/ pr:pragmas md:moduleDec pp:prePeg _:pap p:peg _:spaces
		'|' ']' '\n' atp:afterPeg
			{ mkPegFile pr md emp pp p atp }
;
pragmas :: [PPragma]
	= _:spaces pr:pragma prs:pragmas	{ pr : prs }
	/ _:spaces				{ [] }
;
pragma :: PPragma
	= '{' '-' '#' _:spaces 'L' 'A' 'N' 'G' 'U' 'A' 'G' 'E' _:spaces
		s:pragmaItems _:pragmaEnd _:spaces	{ LanguagePragma s }
	/ '{' '-' '#' _:spaces s:pragmaStr _:pragmaEnd	{ OtherPragma s }
;
pragmaStr :: String
	= !_:pragmaEnd c s:pragmaStr				{ c : s }
	/							{ "" }
;
pragmaItems :: [String]
	= t:typToken ',' _:spaces i:pragmaItems			{ t : i }
	/ t:typToken						{ [t] }
;
pragmaEnd :: ()
	= _:spaces '#' '-' '}'					{ () }
;
moduleDec :: Maybe ([String], Maybe String)
	= 'm' 'o' 'd' 'u' 'l' 'e' _:spaces
		n:moduleName _:spaces
		'(' _:spaces s:moduleDecStr _:whr
							{ Just (n, Just s) }
	/ 'm' 'o' 'd' 'u' 'l' 'e' _:spaces
		n:moduleName _:spaces 'w' 'h' 'e' 'r' 'e' _:spaces
							{ Just (n, Nothing) }
	/						{ Nothing }
;
moduleName :: ModuleName
	= t:typ '.' n:moduleName			{ t : n }
	/ t:typ						{ [t] }
;
moduleDecStr :: String
	= !_:whr c s:moduleDecStr			{ c : s }
	/						{ "" }
;
whr :: ()
	= _:spaces ')' _:spaces 'w' 'h' 'e' 'r' 'e'	{ () }
;
preImpPap :: String
	= !_:importPapillon !_:pap c pip:preImpPap	{ cons c pip }
	/					{ emp }
;
prePeg :: String
	= !_:pap c pp:prePeg	{ cons c pp }
	/					{ emp }
;
afterPeg :: String
	= c atp:afterPeg		{ cons c atp }
	/					{ emp }
;
importPapillon :: ()
	= "import":varToken "Text":typToken '.' _:spaces "Papillon":typToken
		!'.'
		{ () }
;
varToken :: String
	= v:variable _:spaces			{ v }
;
typToken :: String
	= t:typ _:spaces			{ t }
;
pap :: ()
	= '\n' '[' 'p' 'a' 'p' 'i' 'l' 'l' 'o' 'n' '|' '\n'	{ () }
;
peg :: TTPeg
	= _:spaces s:sourceType p:peg_		{ mkTTPeg s p }
	/ p:peg_				{ mkTTPeg tString p }
;
sourceType :: String
	= "source":varToken ':' _:spaces v:typToken	{ v }
;
peg_ :: Peg
	= _:spaces d:definition p:peg_	{ cons d p }
	/ 	{ emp }
;
definition :: Definition
	= v:variable _:spaces ':' ':'
		_:spaces t:hsTypeArr _:spaces '='
		_:spaces sel:selection _:spaces ';'	{ mkDef v t sel }
	/ v:variable _:spaces '<' '-' _:spaces
		sel:plainSelection _:spaces ';'		{ PlainDefinition v sel }
;
selection :: Selection
	= s:normalSelection	{ s }
	/ s:plainSelection	{ s }
;
normalSelection :: Selection
	= ex:expressionHs _:spaces '/' _:spaces sel:normalSelection
				{ Selection $ ex : expressions sel }
	/ ex:expressionHs	{ Selection [ex] }
;
plainSelection :: Selection
	= ex:plainExpressionHs _:spaces '/' _:spaces sel:plainSelection
				{ PlainSelection $ ex : plainExpressions sel }
	/ ex:plainExpressionHs	{ PlainSelection [ex] }
;
expressionHs :: ExpressionHs
	= e:expression _:spaces '{' _:spaces h:hsExpLam _:spaces '}'
		{ ExpressionHs e h }
;
plainExpressionHs :: ExpressionHs
	= rfs:(rf:plainReadFromLs _:spaces { rf })* { PlainExpressionHs rfs }
;
plainReadFromLs :: ReadFrom
	= rf:readFromLs	{ rf }
	/ rf:selectCharsLs	{ rf }
;
expression :: Expression
	= l:nameLeaf_ _:spaces e:expression	{ cons l e }
	/ 	{ emp }
;
nameLeaf_ :: NameLeaf_
	= '!' nl:nameLeafNoCom _:spaces com:comForErr?
						{ NotAfter nl $ maybe "" id com }
	/ c:[isAmp c] nl:nameLeaf		{ After nl }
	/ nl:nameLeaf				{ Here nl }
;
nameLeaf :: NameLeaf
	= n:pat1 _:spaces com:comForErr? ':' (rf, p):leaf
		{ NameLeaf (n, maybe "" id com) rf p }
	/ n:pat1 _:spaces com:comForErr?
		{ NameLeaf (n, maybe "" id com) FromToken Nothing }
;
nameLeafNoCom :: NameLeaf
	= n:pat1 _:spaces com:comForErr? ':' (rf, p):leaf
		{ NameLeaf (n, maybe "" id com) rf p }
	/ n:pat1 _:spaces
		{ NameLeaf (n, "") FromToken Nothing }
;
comForErr :: String
	= '{' '-' '#' _:spaces '"' s:stringLit '"' _:spaces '#' '-' '}' _:spaces
						{ s }
;
leaf :: (ReadFrom, Maybe (ExpQ, String))
	= rf:readFromLs t:test			{ (rf, Just t) }
	/ rf:readFromLs				{ (rf, Nothing) }
	/ t:test				{ (FromToken, Just t) }
;
patOp :: PatQ
	= p:pat o:opConName po:patOp		{ uInfixP p o po }
	/ p:pat _:spaces q:[isBQ q] t:typ q_:[isBQ q_] _:spaces po:patOp
						{ uInfixP p (mkName t) po }
	/ p:pat					{ p }
;
pat :: PatQ
	= t:typ _:spaces ps:pats		{ conToPatQ t ps }
	/ '(' o:opConName ')'_:spaces ps:pats	{ conP o ps }
	/ p:pat1				{ p }
;
pat1 :: PatQ
	= t:typ					{ conToPatQ t emp }
	/ "_":variable				{ wildP }
	/ n:variable				{ strToPatQ n }
	/ i:integer				{ litP (integerL i) }
	/ '-' _:spaces i:integer		{ litP (integerL $ - i) }
	/ '\'' c:charLit '\''			{ charP c }
	/ '"' s:stringLit '"'			{ stringP s }
	/ '(' p:patList ')'			{ tupP p }
	/ '[' p:patList ']'			{ listP p }
;
patList :: [PatQ]
	= p:patOp _:spaces ',' _:spaces ps:patList
						{ p : ps }
	/ p:patOp				{ [p] }
	/					{ [] }
;
opConName :: Name
	= ':' ot:opTail				{ mkName $ colon : ot }
;
charLit :: Char
	= c:[isAlphaNumOt c]			{ c }
	/ '\\' c:escapeC			{ c }
;
stringLit :: String
	= c:[isStrLitC c] s:stringLit			{ cons c s }
	/ '\\' c:escapeC s:stringLit			{ c : s }
	/						{ emp }
;
escapeC :: Char
	= '"'					{ '"' }
	/ '\''					{ '\'' }
	/ '\\'					{ '\\' }
	/ 'n'					{ '\n' }
	/ 't'					{ tab }
;
pats :: PatQs
	= p:pat _:spaces ps:pats		{ cons p ps }
	/					{ emp }
;
readFromLs :: ReadFrom
	= rf:readFrom '*'			{ FromList rf }
	/ rf:readFrom '+'			{ FromList1 rf }
	/ rf:readFrom '?'			{ FromOptional rf }
	/ rf:readFrom				{ rf }
;
readFrom :: ReadFrom
	= v:variable				{ FromVariable v }
	/ '(' s:selection ')'			{ FromSelection s }
;
selectCharsLs :: ReadFrom
	= rf:selectChars '*'			{ FromList rf }
	/ rf:selectChars '+'			{ FromList1 rf }
	/ rf:selectChars '?'			{ FromOptional rf }
	/ rf:selectChars			{ rf }
;
selectChars :: ReadFrom
	= '[' cs:(c:[isLower c] { c })+ ']'	{ FromTokenChars cs }
;
test :: (ExR, String)
	= '[' h:hsExpLam _:spaces com:comForErr? ']'	{ (h, maybe "" id com) }
;
hsExpLam :: ExR
	= '\\' _:spaces ps:pats _:spaces '-' c:[isGt c] _:spaces e:hsExpTyp
					{ lamE ps e }
	/ e:hsExpTyp			{ e }
;
hsExpTyp :: ExR
	= eo:hsExpOp ':' ':' _:spaces t:hsTypeArr
					{ sigE eo t }
	/ eo:hsExpOp			{ eo }
;
hsExpOp :: ExR
	= l:hsExp _:spaces o:hsOp _:spaces r:hsExpOp
					{ uInfixE (getEx l) o r }
	/ e:hsExp			{ getEx e }
;
hsOp :: ExR
	= c:[isOpHeadChar c] o:opTail 	{ varE (mkName (cons c o)) }
	/ ':' !':' o:opTail		{ conE (mkName (':' : o)) }
	/ c:[isBQ c] v:variable c_:[isBQ c_]
					{ varE (mkName v) }
	/ c:[isBQ c] t:typ c_:[isBQ c_]
					{ conE (mkName t) }
;
opTail :: String
	= c:[isOpTailChar c] s:opTail	{ cons c s }
	/				{ emp }
;
hsExp :: Ex
	= e:hsExp1 _:spaces h:hsExp	{ applyExR e h }
	/ e:hsExp1			{ toEx e }
;
hsExp1 :: ExR
	= '(' l:(e:hsExpTyp {e})? _:spaces o:hsOp _:spaces r:(e:hsExpTyp {e})? ')'
					{ infixE l o r }
	/ '(' et:hsExpTpl ')'		{ tupE et }
	/ '[' et:hsExpTpl ']'		{ listE et }
	/ v:variable			{ varE (mkName v) }
	/ t:typ				{ conE (mkName t) }
	/ i:integer _:spaces		{ litE (integerL i) }
	/ '\'' c:charLit '\''		{ litE (charL c) }
	/ '"' s:stringLit '"'		{ litE (stringL s) }
	/ '-' _:spaces e:hsExp1		{ appE (varE $ mkName "negate") e }
;
hsExpTpl :: ExRL
	= e:hsExpLam _:spaces c:[isComma c] _:spaces et:hsExpTpl
					{ cons e et }
	/ e:hsExpLam			{ cons e emp }
	/				{ emp }
;
hsTypeArr :: TypeQ
	= l:hsType '-' c:[isGt c] _:spaces r:hsTypeArr
					{ appT (appT arrowT (getTyp l)) r }
	/ t:hsType			{ getTyp t }
;
hsType :: Typ
	= t:hsType1 ts:hsType		{ applyTyp (toTyp t) ts }
	/ t:hsType1			{ toTyp t }
;
hsType1 :: TypeQ
	= '[' ']' _:spaces		{ listT }
	/ '[' t:hsTypeArr ']' _:spaces	{ appT listT t }
	/ '(' _:spaces tt:hsTypeTpl ')'	{ tupT tt }
	/ t:typToken			{ conT (mkName t) }
	/ '(' '-' c:[isGt c] ')' _:spaces	{ arrowT }
;
hsTypeTpl :: TypeQL
	= t:hsTypeArr c:[isComma c] _:spaces tt:hsTypeTpl
					{ cons t tt }
	/ t:hsTypeArr			{ cons t emp }
	/				{ emp }
;
typ :: String
	= u:upper t:tvtail	{ cons u t }
;
variable :: String
	= l:lower t:tvtail	{ cons l t }
;
tvtail :: String
	= a:alpha t:tvtail	{ cons a t }
	/ 	{ emp }
;
integer :: Integer
	= dh:digit ds:(d:digit { d })*	{ read (cons dh ds) }
;
alpha :: Char
	= u:upper	{ u }
	/ l:lower	{ l }
	/ d:digit	{ d }
	/ '\''		{ '\'' }
;
upper :: Char
	= u:[isUpper u]		{ u }
;
lower :: Char
	= l:[isLowerU l]	{ l }
;
digit :: Char
	= d:[isDigit d]		{ d }
;
spaces :: ()
	= _:space _:spaces	{ () }
	/ 			{ () }
;
space :: ()
	= s:[isSpace s]				{ () }
	/ '-' '-' _:notNLString _:newLine	{ () }
	/ _:comment				{ () }
;
notNLString :: String
	= !_:newLine c s:notNLString		{ cons c s }
	/					{ emp }
;
newLine :: ()
	= '\n'					{ () }
;
comment :: ()
	= '{' '-' !'#' _:comments _:comEnd	{ () }
;
comments :: ()
	= _:notComStr _:comment _:comments	{ () }
	/ _:notComStr				{ () }
;
notComStr :: ()
	= !_:comment !_:comEnd _ _:notComStr	{ () }
	/					{ () }
;
comEnd :: ()
	= '-' '}'				{ () }
;

|]
