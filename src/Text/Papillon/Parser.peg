{-# LANGUAGE PackageImports, FlexibleContexts #-}

module Text.Papillon.Parser (
	Peg,
	Definition,
	NameLeaf,
	parse,
	dv_peg,
	dv_pegFile,
	Leaf_(..)
) where

import Data.Char
import Control.Monad
import "monads-tf" Control.Monad.State
import "monads-tf" Control.Monad.Error
import Control.Monad.Trans.Error (Error(..))
import Language.Haskell.TH

type Nil = ()
type Leaf = Either String ExR
data Leaf_ = NotAfter Leaf | Here Leaf
notAfter, here :: Leaf -> Leaf_
notAfter = NotAfter
here = Here
type NameLeaf = (PatQ, Leaf_)
type Expression = [NameLeaf]
type ExpressionHs = (Expression, ExR)
type Selection = [ExpressionHs]
type Typ = Name
type Definition = (String, Typ, Selection)
type Peg = [Definition]

type Ex = ExpQ -> ExpQ
type ExR = ExpQ

left :: b -> Either a b
right :: a -> Either a b
left = Right
right = Left

nil :: Nil
nil = ()

cons :: a -> [a] -> [a]
cons = (:)

type PatQs = [PatQ]

mkNameLeaf :: PatQ -> b -> (PatQ, b)
mkNameLeaf = (,)

strToPatQ :: String -> PatQ
strToPatQ = varP . mkName

conToPatQ :: String -> [PatQ] -> PatQ
conToPatQ t ps = conP (mkName t) ps

mkExpressionHs :: a -> Ex -> (a, ExR)
mkExpressionHs x y = (x, getEx y)

mkDef :: a -> String -> c -> (a, Name, c)
mkDef x y z = (x, mkName y, z)

toExp :: String -> Ex
toExp v = \f -> f `appE` varE (mkName v)

apply :: String -> Ex -> Ex
apply f x = \g -> x (toExp f g)

getEx :: Ex -> ExR
getEx ex = ex (varE $ mkName "id")

empty :: [a]
empty = []

type PegFile = (String, Peg, String)
mkPegFile :: a -> b -> c -> (a, b, c)
mkPegFile = (,,)

true :: Bool
true = True

isEqual, isSlash, isSemi,
	isColon, isOpenWave, isCloseWave, isLowerU, isNot :: Char -> Bool
isEqual = (== '=')
isSlash = (== '/')
isSemi = (== ';')
isColon = (== ':')
isOpenWave = (== '{')
isCloseWave = (== '}')
isLowerU c = isLower c || c == '_'
isNot = (== '!')

isOpenBr, isP, isA, isI, isL, isO, isN, isBar, isCloseBr, isNL :: Char -> Bool
[isOpenBr, isP, isA, isI, isL, isO, isN, isBar, isCloseBr, isNL] =
	map (==) "[pailon|]\n"

[papillon|

pegFile :: PegFile
	= pp:prePeg _:pap p:peg _:spaces _:[isBar] _:[isCloseBr]
		_:[isNL] atp:afterPeg		{ mkPegFile pp p atp }
;
prePeg :: String
	= _:!pap c:[const true] pp:prePeg	{ cons c pp }
	/					{ empty }
;
afterPeg :: String
	= c:[const true] atp:afterPeg		{ cons c atp }
	/					{ empty }
;
pap :: Nil
	= _:[isNL] _:[isOpenBr] _:[isP] _:[isA] _:[isP] _:[isI] _:[isL] _:[isL]
		_:[isO] _:[isN] _:[isBar] _:[isNL]	{ nil }
;
peg :: Peg
	= _:spaces d:definition p:peg	{ cons d p }
	/ 	{ empty }
;
definition :: Definition
	= v:variable _:spaces _:[isColon] _:[isColon]
		_:spaces t:typ _:spaces _:[isEqual]
		_:spaces sel:selection _:spaces _:[isSemi]	{ mkDef v t sel }
;
selection :: Selection
	= ex:expressionHs _:spaces _:[isSlash] _:spaces sel:selection	{ cons ex sel }
	/ ex:expressionHs	{ cons ex empty }
;
expressionHs :: ExpressionHs
	= e:expression _:spaces _:[isOpenWave] _:spaces h:hsExp
		_:spaces _:[isCloseWave]	{ mkExpressionHs e h }
;
expression :: Expression
	= l:nameLeaf _:spaces e:expression	{ cons l e }
	/ 	{ empty }
;
nameLeaf :: NameLeaf
	= n:pat _:[isColon] l:leaf_		{ mkNameLeaf n l }
;
pat :: PatQ
	= n:variable				{ strToPatQ n }
	/ t:typ _:spaces ps:pats		{ conToPatQ t ps }
;
pats :: PatQs
	= p:pat ps:pats				{ cons p ps }
	/					{ empty }
;
leaf_ :: Leaf_
	= _:[isNot] l:leaf	{ notAfter l }
	/ l:leaf		{ here l }
;
leaf :: Leaf
	= t:test	{ left t }
	/ v:variable	{ right v }
;
test :: ExR
	= _:[isOpenBr] h:hsExp _:[isCloseBr]	{ getEx h }
;
hsExp :: Ex
	= v:variable _:spaces h:hsExp	{ apply v h }
	/ v:variable	{ toExp v }
;
typ :: String
	= u:upper t:tvtail	{ cons u t }
;
variable :: String
	= l:lower t:tvtail	{ cons l t }
;
tvtail :: String
	= a:alpha t:tvtail	{ cons a t }
	/ 	{ empty }
;
alpha :: Char
	= u:upper	{ u }
	/ l:lower	{ l }
	/ d:digit	{ d }
;
upper :: Char
	= u:[isUpper]	{ u }
;
lower :: Char
	= l:[isLowerU]	{ l }
;
digit :: Char
	= d:[isDigit]	{ d }
;
spaces :: Nil
	= _:space _:spaces	{ nil }
	/ 	{ nil }
;
space :: Nil
	= _:[isSpace]	{ nil }
;

|]
