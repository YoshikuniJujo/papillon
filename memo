2013.06.17 Mon.

先頭と末尾の {} 内はそのまま String として出力してしまおうか。
import 等が TH で扱えないので。
QuasiQuote の parser と pappy 的な file 出力の parser を別にすれば良い。
前者の前後に {} を追加するとか。
しかし、それだとコードのなかで {} が使えなくて不便すぎるので、
先頭と末尾は本体部分と == とかで分けたらいいかもしれない。
これはコードに出てこないので。

あるいは [papillon| と |] でくくれば、peggy っぽいコードと類似した感じとなる。
これはある意味美しいかもしれない。

つまり import Papillon の有無だけでそのふたつを分けることができる。
しかも、場合によっては import Papillon は別に無害だ。

type Result v = Maybe (v, Derivs)
type PackratM = StateT Derivs Maybe

data Derivs = Derivs {
	dv... :: Result ...,
	dv... :: Result ...,
	dv... :: Result ...,
	dvChars :: Result Char
 }

dv...M :: PackratM ...
dv...M = StateT dv...

dv...M :: PackratM ...
dv...M = StateT dv...

dv...M :: PackratM ...
dv...M = StateT dv...

parse :: String -> Derivs
parse s = d where
	d = Derivs ... ... ... chars
	... = runStateT p... d
	... = runStateT p... d
	... = runStateT p... d
	chars = flip runStateT d $ do
		c : s' <- return s
		put $ parse s'
		return c

p... :: PMonad ...
p... = do
	... <- dv...M
	if ... ...
	then return ...
	else fail "not match"

まずは葉の部分から変換していけばいいかもしれない。
その葉を do のなかで集める。

2013.06.18 Tue.

'return を使ったほうが TH として使うときには便利だけど、
mkName "return" を使ったほうが preprocessor として使うときには便利。
