2013.06.17 Mon.

先頭と末尾の {} 内はそのまま String として出力してしまおうか。
import 等が TH で扱えないので。
QuasiQuote の parser と pappy 的な file 出力の parser を別にすれば良い。
前者の前後に {} を追加するとか。
しかし、それだとコードのなかで {} が使えなくて不便すぎるので、
先頭と末尾は本体部分と == とかで分けたらいいかもしれない。
これはコードに出てこないので。

あるいは [papillon| と |] でくくれば、peggy っぽいコードと類似した感じとなる。
これはある意味美しいかもしれない。

つまり import Papillon の有無だけでそのふたつを分けることができる。
しかも、場合によっては import Papillon は別に無害だ。

type Result v = Maybe (v, Derivs)
type PackratM = StateT Derivs Maybe

data Derivs = Derivs {
	dv... :: Result ...,
	dv... :: Result ...,
	dv... :: Result ...,
	dvChars :: Result Char
 }

dv...M :: PackratM ...
dv...M = StateT dv...

dv...M :: PackratM ...
dv...M = StateT dv...

dv...M :: PackratM ...
dv...M = StateT dv...

parse :: String -> Derivs
parse s = d where
	d = Derivs ... ... ... chars
	... = runStateT p... d
	... = runStateT p... d
	... = runStateT p... d
	chars = flip runStateT d $ do
		c : s' <- return s
		put $ parse s'
		return c

p... :: PMonad ...
p... = do
	... <- dv...M
	if ... ...
	then return ...
	else fail "not match"

まずは葉の部分から変換していけばいいかもしれない。
その葉を do のなかで集める。

2013.06.18 Tue.

'return を使ったほうが TH として使うときには便利だけど、
mkName "return" を使ったほうが preprocessor として使うときには便利。

先読みが必要か。

2013.06.19 Wed.

右辺に出てこないものについては dv_...M を作らないようにしよう。
Maybe ではなく Either ParseError というようにする。
もっと一般化し、s -> Either ParseError (c, s) のようにしよう。
また、papillon で、flipMaybe をちゃんとくっつけるようにする必要がある。
また、Text/Papillon/Parser.hs を git から外そう。

2013.06.20 Thu.

case getToken s of
	Just (c, s) -> do
		put $ parse s
		return c
	Nothing -> throwError $ strMsg "eof"

次にすることは ! の形を変えることだ。
今は var:!hoge のような形だが、本来ならば
!var:hoge のような形にするべきだろう。
もちろん !var:hoge は !_:hoge と書くべきだが、
!"hoge":str のような形が作れるし、さらに言えば !'\n' のような形は便利だ。
