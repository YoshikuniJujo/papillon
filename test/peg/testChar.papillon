{-# LANGUAGE PackageImports, QuasiQuotes, FlexibleContexts #-}

import Text.Papillon

import Data.Char

import "monads-tf" Control.Monad.State
import "monads-tf" Control.Monad.Error
import Control.Monad.Trans.Error (Error(..))

type Nil = ()
nil :: Nil
nil = ()
cons :: a -> [a] -> [a]
cons = (:)
empty :: [a]
empty = []

true :: Bool
true = True

main :: IO ()
main = case dv_oneTwoThree $ parse "123" of
	Right ((), _) -> putStrLn "OK!"
	Left err -> putStrLn $ "not matched: " ++ err

[papillon|

oneTwoThree :: Nil
	= "123":string	{ nil }
;
string :: String
	= c s:string	{ cons c s }
	/		{ empty }
;
three :: Nil
	= '3'		{ nil }
;
other :: Nil
	= '3':some	{ nil }
;
some :: Char
	= c:[isDigit]	{ c }
;

|]
