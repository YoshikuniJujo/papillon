{-# LANGUAGE QuasiQuotes, TypeFamilies, UndecidableInstances #-}

import Text.Papillon

main :: IO ()
main = do
	case dv_something $ parse initialPos "parse fail" of
		Right (r, _) -> putStrLn $ "no no it's success: " ++ show r
		Left pe -> putStrLn $ "OK! parse failed: " ++ showParseError pe
	case dv_more $ parse initialPos "" of
		Right (r, _) -> putStrLn $ "no no it's success: " ++ show r
		Left pe -> putStrLn $ "OK! parse failed: " ++ showParseError pe
	case dv_other $ parse initialPos "parse hoge" of
		Right (r, _) -> putStrLn $ "no no it's success: " ++ show r
		Left pe -> putStrLn $ "OK! parse failed: " ++ showParseError pe

showParseError :: ParseError (Pos String) -> String
showParseError (ParseError c m com (ListPos (CharPos p)) d ns) =
	unwords (map (showReading d) ns) ++ (if null ns then "" else " ") ++
	m ++ c ++
	(if null com then "" else " {- " ++ com ++ " -} ") ++
	" at position: " ++ show p

showReading :: Derivs -> String -> String
showReading d "dv_string" = case dv_string d of
	Right (s, _) -> show s
	Left _ -> error "bad"
showReading d "dv_other" = case dv_other d of
	Right (s, _) -> show s
	Left _ -> error "bad"
showReading _ n = "yet: " ++ n

type Nil = ()
nil :: Nil
nil = ()
cons :: a -> [a] -> [a]
cons = (:)
emp :: [a]
emp = []

[papillon|

more :: Char = c						{ c }
;
something :: Nil = !_:other {-# "not followed by other" #-}	{ nil }
;
other :: Nil = "parse fail" {-# "it's parse fail" #-} :string	{ nil }
;
string :: String
	= c s:string						{ cons c s }
	/							{ emp }
;

|]
