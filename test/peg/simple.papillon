{-# LANGUAGE QuasiQuotes, TypeFamilies #-}

import Text.Papillon

main :: IO ()
main = case hello $ parse "hello" of
	Right (r, _) -> print r
	Left err -> putStrLn $ showParseError err

showParseError :: ParseError (Pos String) Derivs -> String
showParseError pe =
	unwords (map (showReading d) ns) ++ (if null ns then "" else " ") ++
	m ++ c ++ (if null com then "" else " {- " ++ com ++ " -}") ++
	" at position: " ++ show p
	where
	[c, m, com] = ($ pe) `map` [peCode, peMessage, peComment]
	ns = peReading pe
	d = peDerivs pe
	p = pePositionS pe
	

showReading :: Derivs -> String -> String
showReading d "derivsChars" = case derivsChars d of
	Right (c, _) -> show c
	Left _ -> error "bad"
showReading _ n = "yet: " ++ n

[papillon|

hello:: String
	= c s:hello	{ c : s }
	/		{ [] }
;

|]
