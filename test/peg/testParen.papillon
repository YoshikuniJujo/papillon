{-# LANGUAGE QuasiQuotes, TypeFamilies, UndecidableInstances #-}

import Text.Papillon
import Data.Char

main :: IO ()
main = case dv_something $ parse initialPos "335,287" of
	Right (n, _) -> print n
	Left err -> putStrLn $ "not match: " ++ show err

[papillon|

something :: ([Int], [] Int)
	= n1:numbers ',' n2:numbers	{ (n1, n2) }
;
numbers :: [Int]
	= d:[isDigit d] ns:numbers	{ read [d] : ns }
	/				{ [] }
;

|]
