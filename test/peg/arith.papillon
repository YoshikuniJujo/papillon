{-# LANGUAGE QuasiQuotes, FlexibleContexts, TypeFamilies, UndecidableInstances #-}

module Main where

import Text.Papillon

import Data.Char

testExp, testExp', testExp'', testExp''', testErr, testErr', testErr'' :: String
testExp = "3 * (2 + 24) / 8 / 3"
testExp' = "3 + 2 + 24 / 8 / 3"
testExp'' = "50 + 3 * 6"
testExp''' = "3 * (50 + 5) / 8"
testErr = "8 * 2 + + 5 "
testErr' = "***"
testErr'' = "123<456"

main :: IO ()
main = do
	case dv_expression $ parse initialPos testExp of
		Right (d, _) -> print d
		Left s -> putStrLn $ "error: " ++ show s
	case dv_expression $ parse initialPos testErr of
		Right (d, _) -> print d
		Left s -> putStrLn $ "OK! it's fail: " ++ show s
	case dv_expression $ parse initialPos testErr' of
		Right (d, _) -> print d
		Left s -> putStrLn $ "OK! it's fail: " ++ show s
	case dv_expression $ parse initialPos testErr'' of
		Right (d, _) -> print d
		Left s -> putStrLn $ "OK! it's fail: " ++ show s

type LeftInteger = Integer -> Integer
type Nil = ()

readC :: Char -> Int
readC = read . (: "")

mkLeftInteger :: Int -> (Integer -> Integer) -> Integer -> Integer
mkLeftInteger x y = \i -> y (toLeftInteger x i)
toLeftInteger :: Int -> Integer -> Integer
toLeftInteger x = \i -> i * 10 + toInteger x
nil ::Nil
nil = ()
cons :: a -> [a] -> [a]
cons = (:)
empty :: [a]
empty = []
zero :: Integer
zero = 0
isSymA, isSymM, isOpenParen, isCloseParen :: Char -> Bool
isSymA = (`elem` "+-")
isSymM = (`elem` "*/%")
[isOpenParen, isCloseParen] = map (==) "()"

type LeftMul = (Integer -> Integer -> Integer, Integer) -> Integer

mkLeftMul :: Char -> Integer -> LeftMul -> LeftMul
mkLeftMul '*' x y = \oi -> y ((*), toLeftMul x oi)
mkLeftMul '/' x y = \oi -> y (div, toLeftMul x oi)
mkLeftMul '%' x y = \oi -> y (mod, toLeftMul x oi)
mkLeftMul '+' x y = \oi -> y ((+), toLeftMul x oi)
mkLeftMul _ _ _ = error "mkLeftMul"
toLeftMul :: Integer -> LeftMul
toLeftMul x = \(o, i) -> i `o` x

comMul :: Char -> LeftMul -> LeftMul -> LeftMul
comMul s x y = mkLeftMul s (x ((*), 1)) y
toMul :: LeftMul -> LeftMul
toMul v = \(o, i) -> i `o` (v ((*), 1))

getMul :: LeftMul -> Integer
getMul v = v ((*), 1)

true :: Bool
true = True

[papillon|

{-
{-
	{- this {- nested -} is comment -}
-}{--}
-- {-comment-}
-}
expression :: Integer
	= _:spacing v:additive !_:[true] { getMul v }
;
additive :: LeftMul
	= l:multitive s:symbolA r:additive	{ comMul s l r }
	/ v:multitive				{ toMul v }
;
multitive :: LeftMul
-- comment2
	= l:primary s:symbolM r:multitive	{ mkLeftMul s l r }
	/ v:primary				{ toLeftMul v }
;
primary :: Integer
	= d:decimal				{ d }
	/ c:[isOpenParen c] _:spacing v:additive cc:[isCloseParen cc] _:spacing
						{ getMul v }
;
decimal :: Integer
	= d:digits _:spacing		{ d zero }
;
digits :: LeftInteger
	= d:digit ds:digits		{ mkLeftInteger d ds }
	/ d:digit			{ toLeftInteger d }
;
digit :: Int
	= d:[isDigit d]			{ readC d }
;
symbolA :: Char
	= s:symCharsA _:spacing		{ s }
;
symbolM :: Char
	= s:symCharsM _:spacing		{ s }
;
symCharsA :: Char
	= s:[isSymA s]			{ s }
;
symCharsM :: Char
	= s:[isSymM s]			{ s }
;
spacing :: Nil
	= s:[isSpace s] _:spacing	{ () }
	/				{ () }
;
|]
